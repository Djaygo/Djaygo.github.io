---
// Interactive network background component with hidden config
---

<div class="fixed inset-0 z-0 pointer-events-none" id="network-container">
  <canvas id="network-canvas" class="w-full h-full pointer-events-auto"></canvas>
  <div class="absolute inset-0 bg-gradient-to-b from-transparent via-white/50 to-white dark:via-slate-900/50 dark:to-slate-900"></div>
</div>

<!-- Theme transition overlay -->
<div id="theme-transition" class="theme-transition-overlay"></div>

<!-- Floating Settings Button -->
<button
  id="open-network-config"
  class="fixed bottom-4 right-4 z-40 w-10 h-10 rounded-full bg-white/80 dark:bg-slate-800/80 backdrop-blur-sm border border-gray-200 dark:border-slate-700 shadow-lg flex items-center justify-center text-muted hover:text-primary hover:scale-110 hover:shadow-xl transition-all duration-300 group"
  title="Settings (Ctrl+Shift+G)"
>
  <svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5 transition-transform duration-500 group-hover:rotate-90" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <circle cx="12" cy="12" r="3"/>
    <path d="M12 1v2M12 21v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M1 12h2M21 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42"/>
  </svg>
</button>

<!-- Hidden Config Panel -->
<div id="network-config" class="fixed top-4 right-4 z-50 opacity-0 pointer-events-none translate-x-4 transition-all duration-300 ease-out">
  <div class="bg-white/95 dark:bg-slate-800/95 backdrop-blur-md rounded-xl shadow-2xl p-4 w-72 border border-gray-200 dark:border-slate-700 max-h-[85vh] flex flex-col">
    <div class="flex justify-between items-center mb-3 flex-shrink-0">
      <h3 class="font-bold text-base">Settings</h3>
      <button id="close-config" class="text-gray-400 hover:text-gray-600 dark:hover:text-gray-200 text-xl leading-none">&times;</button>
    </div>

    <div class="space-y-3 text-xs overflow-y-auto flex-grow pr-1">
      <!-- Theme Mode -->
      <div class="border-b border-gray-200 dark:border-slate-700 pb-3">
        <h4 class="font-semibold mb-2 text-muted text-xs uppercase tracking-wide">Theme</h4>
        <div class="flex gap-1 bg-gray-200 dark:bg-slate-700 rounded-lg p-0.5">
          <button id="theme-light" class="flex-1 px-2 py-1 rounded-md transition-colors text-center" title="Light">‚òÄÔ∏è</button>
          <button id="theme-dark" class="flex-1 px-2 py-1 rounded-md transition-colors text-center" title="Dark">üåô</button>
          <button id="theme-system" class="flex-1 px-2 py-1 rounded-md transition-colors text-center" title="System">üíª</button>
        </div>
      </div>

      <!-- Nodes -->
      <div class="border-b border-gray-200 dark:border-slate-700 pb-3">
        <h4 class="font-semibold mb-2 text-muted text-xs uppercase tracking-wide">Nodes</h4>

        <label class="block mb-1.5">
          <span class="text-muted flex justify-between"><span>Count</span><span id="nodeCount-value">60</span></span>
          <input type="range" id="nodeCount" min="10" max="150" value="60" class="w-full accent-primary h-1.5">
        </label>

        <label class="block mb-1.5">
          <span class="text-muted flex justify-between"><span>Size</span><span id="nodeSize-value">2</span></span>
          <input type="range" id="nodeSize" min="1" max="6" step="0.5" value="2" class="w-full accent-primary h-1.5">
        </label>

        <label class="block mb-1.5">
          <span class="text-muted flex justify-between"><span>Speed</span><span id="nodeSpeed-value">0.3</span></span>
          <input type="range" id="nodeSpeed" min="0.1" max="2" step="0.1" value="0.3" class="w-full accent-primary h-1.5">
        </label>

        <div class="flex items-center gap-2 mb-1.5">
          <label class="flex flex-col items-center gap-1">
            <input type="color" id="nodeColor" value="#6366f1" class="w-8 h-6 rounded cursor-pointer">
            <span class="text-muted text-[10px]">Color</span>
          </label>
          <label class="flex-1">
            <span class="text-muted flex justify-between"><span>Opacity</span><span id="nodeOpacity-value">0.6</span></span>
            <input type="range" id="nodeOpacity" min="0.1" max="1" step="0.1" value="0.6" class="w-full accent-primary h-1.5">
          </label>
        </div>
      </div>

      <!-- Node-to-Node Edges -->
      <div class="border-b border-gray-200 dark:border-slate-700 pb-3">
        <div class="flex items-center justify-between mb-2">
          <h4 class="font-semibold text-muted text-xs uppercase tracking-wide">Node Edges</h4>
          <label class="flex items-center gap-1 cursor-pointer">
            <input type="checkbox" id="nodeEdgesEnabled" checked class="accent-primary w-3 h-3">
            <span class="text-[10px] text-muted">On</span>
          </label>
        </div>

        <label class="block mb-1.5">
          <span class="text-muted flex justify-between"><span>Distance</span><span id="connectionDistance-value">150</span></span>
          <input type="range" id="connectionDistance" min="50" max="300" value="150" class="w-full accent-primary h-1.5">
        </label>

        <div class="flex items-center gap-2">
          <label class="flex flex-col items-center gap-1">
            <input type="color" id="lineColor" value="#6366f1" class="w-8 h-6 rounded cursor-pointer">
            <span class="text-muted text-[10px]">Color</span>
          </label>
          <label class="flex-1">
            <span class="text-muted flex justify-between"><span>Opacity</span><span id="lineOpacity-value">0.15</span></span>
            <input type="range" id="lineOpacity" min="0.05" max="0.5" step="0.05" value="0.15" class="w-full accent-primary h-1.5">
          </label>
        </div>
      </div>

      <!-- Mouse Edges -->
      <div class="border-b border-gray-200 dark:border-slate-700 pb-3">
        <div class="flex items-center justify-between mb-2">
          <h4 class="font-semibold text-muted text-xs uppercase tracking-wide">Mouse Edges</h4>
          <label class="flex items-center gap-1 cursor-pointer">
            <input type="checkbox" id="mouseEdgesEnabled" checked class="accent-primary w-3 h-3">
            <span class="text-[10px] text-muted">On</span>
          </label>
        </div>

        <label class="block mb-1.5">
          <span class="text-muted flex justify-between"><span>Radius</span><span id="mouseRadius-value">200</span></span>
          <input type="range" id="mouseRadius" min="50" max="400" value="200" class="w-full accent-primary h-1.5">
        </label>

        <div class="flex items-center gap-2 mb-1.5">
          <label class="flex flex-col items-center gap-1">
            <input type="color" id="mouseLineColor" value="#6366f1" class="w-8 h-6 rounded cursor-pointer">
            <span class="text-muted text-[10px]">Color</span>
          </label>
          <label class="flex items-center gap-1 cursor-pointer">
            <input type="checkbox" id="mouseLightning" checked class="accent-primary w-3 h-3">
            <span class="text-[10px] text-muted">Lightning</span>
          </label>
        </div>
      </div>

      <!-- Header Edges -->
      <div class="border-b border-gray-200 dark:border-slate-700 pb-3">
        <div class="flex items-center justify-between mb-2">
          <h4 class="font-semibold text-muted text-xs uppercase tracking-wide">Header Edges</h4>
          <label class="flex items-center gap-1 cursor-pointer">
            <input type="checkbox" id="headerEdgesEnabled" checked class="accent-primary w-3 h-3">
            <span class="text-[10px] text-muted">On</span>
          </label>
        </div>

        <label class="block mb-1.5">
          <span class="text-muted flex justify-between"><span>Radius</span><span id="headerRadius-value">300</span></span>
          <input type="range" id="headerRadius" min="100" max="500" value="300" class="w-full accent-primary h-1.5">
        </label>

        <div class="flex items-center gap-2 mb-1.5">
          <label class="flex flex-col items-center gap-1">
            <input type="color" id="headerLineColor" value="#6366f1" class="w-8 h-6 rounded cursor-pointer">
            <span class="text-muted text-[10px]">Color</span>
          </label>
          <label class="flex items-center gap-1 cursor-pointer">
            <input type="checkbox" id="headerLightning" checked class="accent-primary w-3 h-3">
            <span class="text-[10px] text-muted">Lightning</span>
          </label>
        </div>
      </div>

      <!-- Lightning Physics -->
      <div class="border-b border-gray-200 dark:border-slate-700 pb-3">
        <h4 class="font-semibold mb-2 text-muted text-xs uppercase tracking-wide">Lightning</h4>

        <label class="block mb-1.5">
          <span class="text-muted flex justify-between"><span>Jitter</span><span id="lightningJitter-value">0.15</span></span>
          <input type="range" id="lightningJitter" min="0.05" max="0.4" step="0.05" value="0.15" class="w-full accent-primary h-1.5">
        </label>

        <label class="block mb-1.5">
          <span class="text-muted flex justify-between"><span>Segments</span><span id="lightningSegments-value">20</span></span>
          <input type="range" id="lightningSegments" min="10" max="40" step="5" value="20" class="w-full accent-primary h-1.5">
        </label>

        <label class="block">
          <span class="text-muted flex justify-between"><span>Glow</span><span id="lightningGlow-value">4</span></span>
          <input type="range" id="lightningGlow" min="1" max="8" step="0.5" value="4" class="w-full accent-primary h-1.5">
        </label>
      </div>

      <!-- Pulse Effect -->
      <div class="border-b border-gray-200 dark:border-slate-700 pb-3">
        <div class="flex items-center justify-between mb-2">
          <h4 class="font-semibold text-muted text-xs uppercase tracking-wide">Pulse</h4>
          <label class="flex items-center gap-1 cursor-pointer">
            <input type="checkbox" id="pulseEnabled" checked class="accent-primary w-3 h-3">
            <span class="text-[10px] text-muted">On</span>
          </label>
        </div>

        <div class="flex items-center gap-2 mb-1.5">
          <label class="flex items-center gap-1 cursor-pointer">
            <input type="checkbox" id="pulseAuto" checked class="accent-primary w-3 h-3">
            <span class="text-[10px] text-muted">Auto</span>
          </label>
          <button id="pulseTrigger" class="px-2 py-0.5 text-[10px] rounded-full bg-gray-200 dark:bg-slate-700 hover:bg-primary hover:text-white transition-colors">Pulse!</button>
        </div>

        <label class="block mb-1.5">
          <span class="text-muted flex justify-between"><span>Speed</span><span id="pulseSpeed-value">50</span></span>
          <input type="range" id="pulseSpeed" min="0" max="100" step="5" value="50" class="w-full accent-primary h-1.5">
        </label>

        <label class="block mb-1.5">
          <span class="text-muted flex justify-between"><span>Width</span><span id="pulseWidth-value">80</span></span>
          <input type="range" id="pulseWidth" min="20" max="200" step="10" value="80" class="w-full accent-primary h-1.5">
        </label>

        <label class="block mb-1.5">
          <span class="text-muted flex justify-between"><span>Intensity</span><span id="pulseIntensity-value">1</span></span>
          <input type="range" id="pulseIntensity" min="0.3" max="2" step="0.1" value="1" class="w-full accent-primary h-1.5">
        </label>

        <label class="block mb-1.5">
          <span class="text-muted flex justify-between"><span>Interval</span><span id="pulseInterval-value">2</span>s</span>
          <input type="range" id="pulseInterval" min="0.5" max="5" step="0.5" value="2" class="w-full accent-primary h-1.5">
        </label>

        <div class="flex items-center gap-2">
          <label class="flex flex-col items-center gap-1">
            <input type="color" id="pulseColor" value="#ff6b6b" class="w-8 h-6 rounded cursor-pointer">
            <span class="text-muted text-[10px]">Color</span>
          </label>
          <label class="flex items-center gap-1 cursor-pointer">
            <input type="checkbox" id="pulseShake" class="accent-primary w-3 h-3">
            <span class="text-[10px] text-muted">Shake nodes</span>
          </label>
        </div>
      </div>

      <!-- Presets -->
      <div class="flex-shrink-0">
        <h4 class="font-semibold mb-2 text-muted text-xs uppercase tracking-wide">Presets</h4>
        <div class="flex gap-1.5 flex-wrap">
          <button data-preset="default" class="px-2 py-0.5 text-[10px] rounded-full bg-gray-200 dark:bg-slate-700 hover:bg-primary hover:text-white transition-colors">Default</button>
          <button data-preset="dense" class="px-2 py-0.5 text-[10px] rounded-full bg-gray-200 dark:bg-slate-700 hover:bg-primary hover:text-white transition-colors">Dense</button>
          <button data-preset="minimal" class="px-2 py-0.5 text-[10px] rounded-full bg-gray-200 dark:bg-slate-700 hover:bg-primary hover:text-white transition-colors">Minimal</button>
          <button data-preset="electric" class="px-2 py-0.5 text-[10px] rounded-full bg-gray-200 dark:bg-slate-700 hover:bg-primary hover:text-white transition-colors">Electric</button>
          <button data-preset="heartbeat" class="px-2 py-0.5 text-[10px] rounded-full bg-gray-200 dark:bg-slate-700 hover:bg-primary hover:text-white transition-colors">Heartbeat</button>
          <button data-preset="rainbow" class="px-2 py-0.5 text-[10px] rounded-full bg-gray-200 dark:bg-slate-700 hover:bg-primary hover:text-white transition-colors">Rainbow</button>
          <button data-preset="matrix" class="px-2 py-0.5 text-[10px] rounded-full bg-gray-200 dark:bg-slate-700 hover:bg-primary hover:text-white transition-colors">Matrix</button>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
  function initNetwork() {
    const canvas = document.getElementById('network-canvas') as HTMLCanvasElement;
    const configPanel = document.getElementById('network-config');
    const openBtnFloat = document.getElementById('open-network-config');
    const openBtnHeader = document.getElementById('open-network-config-header');
    const closeBtn = document.getElementById('close-config');

    if (!canvas || !configPanel) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    let width: number;
    let height: number;
    let nodes: Array<{x: number; y: number; vx: number; vy: number; radius: number; hue?: number; shakeX?: number; shakeY?: number}> = [];
    let mouse = { x: 0, y: 0 };
    let headings: Array<{ x: number; y: number; width: number; height: number }> = [];
    let animationId: number;

    // Pulse waves: each pulse expands outward from origin
    let pulseWaves: Array<{x: number; y: number; radius: number; startTime: number; maxRadius: number}> = [];
    let lastPulseTime = 0;

    // Default config
    const defaultConfig = {
      // Nodes
      nodeCount: 60,
      nodeSize: 2,
      nodeSpeed: 0.3,
      nodeColor: '#6366f1',
      nodeOpacity: 0.6,
      // Node edges
      nodeEdgesEnabled: true,
      connectionDistance: 150,
      lineColor: '#6366f1',
      lineOpacity: 0.15,
      // Mouse edges
      mouseEdgesEnabled: true,
      mouseRadius: 200,
      mouseLineColor: '#6366f1',
      mouseLightning: true,
      // Header edges
      headerEdgesEnabled: true,
      headerRadius: 300,
      headerLineColor: '#6366f1',
      headerLightning: true,
      // Lightning physics
      lightningJitter: 0.15,
      lightningSegments: 20,
      lightningGlow: 4,
      // Pulse effect
      pulseEnabled: true,
      pulseAuto: true,
      pulseSpeed: 50,
      pulseWidth: 80,
      pulseIntensity: 1,
      pulseInterval: 2,
      pulseColor: '#ff6b6b',
      pulseShake: false,
      // Mode
      rainbowMode: false,
    };

    // Presets
    const presets: Record<string, Partial<typeof defaultConfig>> = {
      default: { ...defaultConfig },
      dense: { nodeCount: 120, connectionDistance: 100, nodeSpeed: 0.2, nodeSize: 1.5 },
      minimal: { nodeCount: 25, connectionDistance: 200, nodeSpeed: 0.15, nodeSize: 3, lineOpacity: 0.1, mouseLightning: false, headerLightning: false, pulseEnabled: false },
      electric: { lightningJitter: 0.3, lightningGlow: 6, mouseLightning: true, headerLightning: true, mouseLineColor: '#00d4ff', headerLineColor: '#00d4ff', pulseColor: '#00d4ff', pulseIntensity: 1.5 },
      heartbeat: { pulseEnabled: true, pulseAuto: true, pulseInterval: 0.8, pulseSpeed: 80, pulseWidth: 60, pulseIntensity: 1.5, pulseShake: true, pulseColor: '#ff4757', mouseLightning: false, headerLightning: false },
      rainbow: { rainbowMode: true, nodeCount: 80, nodeOpacity: 0.8, lineOpacity: 0.25, lightningJitter: 0.2 },
      matrix: { nodeColor: '#00ff00', lineColor: '#00ff00', mouseLineColor: '#00ff00', headerLineColor: '#00ff00', nodeCount: 100, nodeSpeed: 0.5, lineOpacity: 0.2, lightningJitter: 0.25, pulseColor: '#00ff00' },
    };

    // Load saved config or use defaults
    let config = { ...defaultConfig };
    try {
      const saved = localStorage.getItem('networkConfig');
      if (saved) {
        config = { ...defaultConfig, ...JSON.parse(saved) };
      }
    } catch (e) {}

    function saveConfig() {
      try {
        localStorage.setItem('networkConfig', JSON.stringify(config));
      } catch (e) {}
    }

    function hexToRgba(hex: string, alpha: number): string {
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    function hslToRgba(h: number, s: number, l: number, a: number): string {
      const c = (1 - Math.abs(2 * l - 1)) * s;
      const x = c * (1 - Math.abs((h / 60) % 2 - 1));
      const m = l - c / 2;
      let r = 0, g = 0, b = 0;
      if (h < 60) { r = c; g = x; }
      else if (h < 120) { r = x; g = c; }
      else if (h < 180) { g = c; b = x; }
      else if (h < 240) { g = x; b = c; }
      else if (h < 300) { r = x; b = c; }
      else { r = c; b = x; }
      return `rgba(${Math.round((r + m) * 255)}, ${Math.round((g + m) * 255)}, ${Math.round((b + m) * 255)}, ${a})`;
    }

    // Draw electrified lightning bolt between two points
    function drawLightning(x1: number, y1: number, x2: number, y2: number, color: string, glowColor: string, intensity: number) {
      const dx = x2 - x1;
      const dy = y2 - y1;
      const dist = Math.sqrt(dx * dx + dy * dy);

      // Number of segments based on distance and config
      const segments = Math.max(3, Math.floor(dist / config.lightningSegments));

      // Perpendicular vector for displacement
      const perpX = -dy / dist;
      const perpY = dx / dist;

      // Generate jagged path points
      const points: {x: number, y: number}[] = [{x: x1, y: y1}];

      for (let i = 1; i < segments; i++) {
        const t = i / segments;
        const baseX = x1 + dx * t;
        const baseY = y1 + dy * t;

        // Random displacement perpendicular to the line (using config jitter)
        const displacement = (Math.random() - 0.5) * dist * config.lightningJitter * intensity;

        points.push({
          x: baseX + perpX * displacement,
          y: baseY + perpY * displacement
        });
      }
      points.push({x: x2, y: y2});

      // Draw glow layer (thicker, more transparent)
      ctx.beginPath();
      ctx.moveTo(points[0].x, points[0].y);
      for (let i = 1; i < points.length; i++) {
        ctx.lineTo(points[i].x, points[i].y);
      }
      ctx.strokeStyle = glowColor;
      ctx.lineWidth = config.lightningGlow;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.stroke();

      // Draw main lightning bolt
      ctx.beginPath();
      ctx.moveTo(points[0].x, points[0].y);
      for (let i = 1; i < points.length; i++) {
        ctx.lineTo(points[i].x, points[i].y);
      }
      ctx.strokeStyle = color;
      ctx.lineWidth = 1.5;
      ctx.stroke();

      // Draw bright core
      ctx.beginPath();
      ctx.moveTo(points[0].x, points[0].y);
      for (let i = 1; i < points.length; i++) {
        ctx.lineTo(points[i].x, points[i].y);
      }
      ctx.strokeStyle = `rgba(255, 255, 255, ${intensity * 0.3})`;
      ctx.lineWidth = 0.5;
      ctx.stroke();
    }

    // Draw simple straight line
    function drawLine(x1: number, y1: number, x2: number, y2: number, color: string) {
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.strokeStyle = color;
      ctx.lineWidth = 1;
      ctx.stroke();
    }

    // Trigger a new pulse wave from mouse position
    function triggerPulse() {
      const maxRadius = Math.max(width, height) * 1.5;
      pulseWaves.push({
        x: mouse.x,
        y: mouse.y,
        radius: 0,
        startTime: performance.now(),
        maxRadius: maxRadius
      });
    }

    // Calculate pulse intensity at a given point
    function getPulseIntensity(x: number, y: number, time: number): number {
      let maxIntensity = 0;

      pulseWaves.forEach(pulse => {
        const dx = x - pulse.x;
        const dy = y - pulse.y;
        const distFromOrigin = Math.sqrt(dx * dx + dy * dy);

        // Distance from the pulse ring
        const distFromRing = Math.abs(distFromOrigin - pulse.radius);

        // Within the pulse width?
        if (distFromRing < config.pulseWidth) {
          // Intensity falls off with distance from ring center
          const ringIntensity = 1 - (distFromRing / config.pulseWidth);

          // Echo effect: intensity decreases as pulse expands (like fading heartbeat)
          const echoFalloff = 1 - (pulse.radius / pulse.maxRadius);

          // Combined intensity
          const intensity = ringIntensity * echoFalloff * config.pulseIntensity;
          maxIntensity = Math.max(maxIntensity, intensity);
        }
      });

      return maxIntensity;
    }

    // Draw edge with pulse effect
    function drawPulsedEdge(x1: number, y1: number, x2: number, y2: number, baseColor: string, baseOpacity: number, time: number) {
      // Get pulse intensity at midpoint of edge
      const midX = (x1 + x2) / 2;
      const midY = (y1 + y2) / 2;
      const pulseIntensity = getPulseIntensity(midX, midY, time);

      if (pulseIntensity > 0.01) {
        // Parse base color and blend with pulse color
        const pulseOpacity = baseOpacity + pulseIntensity * 0.6;

        // Draw pulse glow
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.strokeStyle = hexToRgba(config.pulseColor, pulseIntensity * 0.3);
        ctx.lineWidth = 3 + pulseIntensity * 4;
        ctx.lineCap = 'round';
        ctx.stroke();

        // Draw main line with pulse color blend
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.strokeStyle = hexToRgba(config.pulseColor, Math.min(pulseOpacity, 0.8));
        ctx.lineWidth = 1 + pulseIntensity * 2;
        ctx.stroke();
      } else {
        // Normal edge rendering
        drawLine(x1, y1, x2, y2, hexToRgba(baseColor, baseOpacity));
      }
    }

    function init() {
      resize();
      nodes = [];
      for (let i = 0; i < config.nodeCount; i++) {
        nodes.push({
          x: Math.random() * width,
          y: Math.random() * height,
          vx: (Math.random() - 0.5) * config.nodeSpeed,
          vy: (Math.random() - 0.5) * config.nodeSpeed,
          radius: Math.random() * config.nodeSize + 1,
          hue: Math.random() * 360,
        });
      }
    }

    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
      updateHeaderPosition();
    }

    function updateHeaderPosition() {
      headings = [];
      // Find the site header elements (title h1 and description p)
      const siteHeaderLink = document.getElementById('site-header-link');
      if (siteHeaderLink) {
        // Get the h1 title
        const h1 = siteHeaderLink.querySelector('h1');
        if (h1) {
          const rect = h1.getBoundingClientRect();
          if (rect.width > 0) {
            headings.push({
              x: rect.left + rect.width / 2,
              y: rect.top + rect.height / 2,
              width: rect.width,
              height: rect.height
            });
          }
        }
        // Get the sibling p (description)
        const description = siteHeaderLink.parentElement?.querySelector('p');
        if (description) {
          const rect = description.getBoundingClientRect();
          if (rect.width > 0) {
            headings.push({
              x: rect.left + rect.width / 2,
              y: rect.top + rect.height / 2,
              width: rect.width,
              height: rect.height
            });
          }
        }
      }
    }

    function animate() {
      const currentTime = performance.now();
      ctx.clearRect(0, 0, width, height);

      // Update pulse waves
      if (config.pulseEnabled) {
        // Auto-trigger pulses
        if (config.pulseAuto && currentTime - lastPulseTime > config.pulseInterval * 1000) {
          triggerPulse();
          lastPulseTime = currentTime;
        }

        // Expand pulse radii and remove completed ones
        pulseWaves = pulseWaves.filter(pulse => {
          const elapsed = currentTime - pulse.startTime;
          pulse.radius = elapsed * (config.pulseSpeed / 1000) * 60; // 60fps normalized
          return pulse.radius < pulse.maxRadius;
        });
      }

      nodes.forEach((node, i) => {
        // Apply shake effect from pulses
        let shakeX = 0;
        let shakeY = 0;
        if (config.pulseEnabled && config.pulseShake) {
          const pulseIntensity = getPulseIntensity(node.x, node.y, currentTime);
          if (pulseIntensity > 0.1) {
            const shakeStrength = pulseIntensity * 8;
            shakeX = (Math.random() - 0.5) * shakeStrength;
            shakeY = (Math.random() - 0.5) * shakeStrength;
          }
        }

        node.x += node.vx;
        node.y += node.vy;

        if (node.x < 0 || node.x > width) node.vx *= -1;
        if (node.y < 0 || node.y > height) node.vy *= -1;

        node.x = Math.max(0, Math.min(width, node.x));
        node.y = Math.max(0, Math.min(height, node.y));

        // Update hue for rainbow mode
        if (config.rainbowMode && node.hue !== undefined) {
          node.hue = (node.hue + 0.5) % 360;
        }

        // Render position with shake
        const renderX = node.x + shakeX;
        const renderY = node.y + shakeY;

        // Get pulse intensity for node glow
        const nodePulseIntensity = config.pulseEnabled ? getPulseIntensity(renderX, renderY, currentTime) : 0;

        // Draw node with pulse glow
        if (nodePulseIntensity > 0.1) {
          // Pulse glow around node
          ctx.beginPath();
          ctx.arc(renderX, renderY, node.radius + nodePulseIntensity * 6, 0, Math.PI * 2);
          ctx.fillStyle = hexToRgba(config.pulseColor, nodePulseIntensity * 0.4);
          ctx.fill();
        }

        // Draw node
        ctx.beginPath();
        ctx.arc(renderX, renderY, node.radius, 0, Math.PI * 2);
        ctx.fillStyle = config.rainbowMode
          ? hslToRgba(node.hue!, 0.7, 0.5, config.nodeOpacity)
          : hexToRgba(config.nodeColor, config.nodeOpacity);
        ctx.fill();

        // Connect to nearby nodes
        if (config.nodeEdgesEnabled) {
          for (let j = i + 1; j < nodes.length; j++) {
            const other = nodes[j];

            // Other node's shake
            let otherShakeX = 0;
            let otherShakeY = 0;
            if (config.pulseEnabled && config.pulseShake) {
              const otherPulseIntensity = getPulseIntensity(other.x, other.y, currentTime);
              if (otherPulseIntensity > 0.1) {
                const shakeStrength = otherPulseIntensity * 8;
                otherShakeX = (Math.random() - 0.5) * shakeStrength;
                otherShakeY = (Math.random() - 0.5) * shakeStrength;
              }
            }

            const otherRenderX = other.x + otherShakeX;
            const otherRenderY = other.y + otherShakeY;

            const ndx = node.x - other.x;
            const ndy = node.y - other.y;
            const ndist = Math.sqrt(ndx * ndx + ndy * ndy);

            if (ndist < config.connectionDistance) {
              const opacity = config.lineOpacity * (1 - ndist / config.connectionDistance);

              if (config.pulseEnabled) {
                const baseColor = config.rainbowMode ? config.lineColor : config.lineColor;
                drawPulsedEdge(renderX, renderY, otherRenderX, otherRenderY, baseColor, opacity, currentTime);
              } else {
                const lineColor = config.rainbowMode
                  ? hslToRgba((node.hue! + other.hue!) / 2, 0.7, 0.5, opacity)
                  : hexToRgba(config.lineColor, opacity);
                drawLine(renderX, renderY, otherRenderX, otherRenderY, lineColor);
              }
            }
          }
        }

        // Connect to mouse
        if (config.mouseEdgesEnabled) {
          const dx = node.x - mouse.x;
          const dy = node.y - mouse.y;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (dist < config.mouseRadius) {
            const intensity = 1 - dist / config.mouseRadius;

            if (config.mouseLightning) {
              const mainColor = config.rainbowMode
                ? hslToRgba(node.hue!, 0.8, 0.6, intensity * 0.8)
                : hexToRgba(config.mouseLineColor, intensity * 0.7);
              const glowColor = config.rainbowMode
                ? hslToRgba(node.hue!, 0.6, 0.5, intensity * 0.15)
                : hexToRgba(config.mouseLineColor, intensity * 0.1);
              drawLightning(node.x, node.y, mouse.x, mouse.y, mainColor, glowColor, intensity);
            } else {
              const lineColor = config.rainbowMode
                ? hslToRgba(node.hue!, 0.7, 0.5, intensity * 0.5)
                : hexToRgba(config.mouseLineColor, intensity * 0.4);
              drawLine(node.x, node.y, mouse.x, mouse.y, lineColor);
            }
          }
        }

        // Connect to headings (h1, h2, h3)
        if (config.headerEdgesEnabled && headings.length > 0) {
          headings.forEach(heading => {
            // Calculate distance to nearest point on heading rectangle
            const closestX = Math.max(heading.x - heading.width / 2, Math.min(renderX, heading.x + heading.width / 2));
            const closestY = Math.max(heading.y - heading.height / 2, Math.min(renderY, heading.y + heading.height / 2));
            const hdx = renderX - closestX;
            const hdy = renderY - closestY;
            const hdist = Math.sqrt(hdx * hdx + hdy * hdy);

            if (hdist < config.headerRadius && hdist > 0) {
              const intensity = 1 - hdist / config.headerRadius;

              if (config.headerLightning) {
                const mainColor = config.rainbowMode
                  ? hslToRgba(node.hue!, 0.8, 0.6, intensity * 0.6)
                  : hexToRgba(config.headerLineColor, intensity * 0.5);
                const glowColor = config.rainbowMode
                  ? hslToRgba(node.hue!, 0.6, 0.5, intensity * 0.12)
                  : hexToRgba(config.headerLineColor, intensity * 0.08);
                drawLightning(renderX, renderY, closestX, closestY, mainColor, glowColor, intensity);
              } else {
                const lineColor = config.rainbowMode
                  ? hslToRgba(node.hue!, 0.7, 0.5, intensity * 0.25)
                  : hexToRgba(config.headerLineColor, intensity * 0.25);
                drawLine(renderX, renderY, closestX, closestY, lineColor);
              }
            }
          });
        }
      });

      animationId = requestAnimationFrame(animate);
    }

    function updateConfigUI() {
      // Range inputs with value display
      const rangeInputs = [
        'nodeCount', 'nodeSize', 'nodeSpeed', 'nodeOpacity',
        'connectionDistance', 'lineOpacity',
        'mouseRadius',
        'headerRadius',
        'lightningJitter', 'lightningSegments', 'lightningGlow',
        'pulseSpeed', 'pulseWidth', 'pulseIntensity', 'pulseInterval'
      ];
      rangeInputs.forEach(id => {
        const el = document.getElementById(id) as HTMLInputElement;
        const valueEl = document.getElementById(`${id}-value`);
        if (el) {
          el.value = String(config[id as keyof typeof config]);
          if (valueEl) valueEl.textContent = String(config[id as keyof typeof config]);
        }
      });

      // Color inputs
      ['nodeColor', 'lineColor', 'mouseLineColor', 'headerLineColor', 'pulseColor'].forEach(id => {
        const el = document.getElementById(id) as HTMLInputElement;
        if (el) el.value = String(config[id as keyof typeof config]);
      });

      // Checkbox inputs
      const checkboxInputs = [
        'nodeEdgesEnabled', 'mouseEdgesEnabled', 'headerEdgesEnabled',
        'mouseLightning', 'headerLightning',
        'pulseEnabled', 'pulseAuto', 'pulseShake'
      ];
      checkboxInputs.forEach(id => {
        const el = document.getElementById(id) as HTMLInputElement;
        if (el) el.checked = Boolean(config[id as keyof typeof config]);
      });
    }

    function setupConfigListeners() {
      // Range inputs
      const rangeInputs = [
        'nodeCount', 'nodeSize', 'nodeSpeed', 'nodeOpacity',
        'connectionDistance', 'lineOpacity',
        'mouseRadius',
        'headerRadius',
        'lightningJitter', 'lightningSegments', 'lightningGlow',
        'pulseSpeed', 'pulseWidth', 'pulseIntensity', 'pulseInterval'
      ];
      rangeInputs.forEach(id => {
        const el = document.getElementById(id) as HTMLInputElement;
        const valueEl = document.getElementById(`${id}-value`);
        if (el) {
          el.addEventListener('input', () => {
            const val = parseFloat(el.value);
            (config as any)[id] = val;
            if (valueEl) valueEl.textContent = String(val);
            if (id === 'nodeCount' || id === 'nodeSize') init();
            saveConfig();
          });
        }
      });

      // Color inputs
      ['nodeColor', 'lineColor', 'mouseLineColor', 'headerLineColor', 'pulseColor'].forEach(id => {
        const el = document.getElementById(id) as HTMLInputElement;
        if (el) {
          el.addEventListener('input', () => {
            (config as any)[id] = el.value;
            config.rainbowMode = false;
            saveConfig();
          });
        }
      });

      // Checkbox inputs
      const checkboxInputs = [
        'nodeEdgesEnabled', 'mouseEdgesEnabled', 'headerEdgesEnabled',
        'mouseLightning', 'headerLightning',
        'pulseEnabled', 'pulseAuto', 'pulseShake'
      ];
      checkboxInputs.forEach(id => {
        const el = document.getElementById(id) as HTMLInputElement;
        if (el) {
          el.addEventListener('change', () => {
            (config as any)[id] = el.checked;
            saveConfig();
          });
        }
      });

      // Pulse trigger button
      const pulseTriggerBtn = document.getElementById('pulseTrigger');
      if (pulseTriggerBtn) {
        pulseTriggerBtn.addEventListener('click', () => {
          triggerPulse();
        });
      }

      // Also trigger pulse on canvas click
      canvas.addEventListener('click', (e) => {
        if (config.pulseEnabled) {
          mouse.x = e.clientX;
          mouse.y = e.clientY;
          triggerPulse();
        }
      });

      // Presets
      document.querySelectorAll('[data-preset]').forEach(btn => {
        btn.addEventListener('click', () => {
          const presetName = (btn as HTMLElement).dataset.preset!;
          const preset = presets[presetName];
          if (preset) {
            Object.assign(config, { ...defaultConfig, ...preset });
            updateConfigUI();
            init();
            saveConfig();
          }
        });
      });
    }

    // Theme toggle functionality
    const themeLightBtn = document.getElementById('theme-light');
    const themeDarkBtn = document.getElementById('theme-dark');
    const themeSystemBtn = document.getElementById('theme-system');

    function getThemePreference(): 'light' | 'dark' | 'system' {
      try {
        return (localStorage.getItem('theme') as 'light' | 'dark' | 'system') || 'system';
      } catch (e) {
        return 'system';
      }
    }

    function applyTheme(theme: 'light' | 'dark' | 'system', animate = true) {
      const wasDark = document.documentElement.classList.contains('dark');
      const isDark = theme === 'dark' ||
        (theme === 'system' && window.matchMedia('(prefers-color-scheme: dark)').matches);

      // Only animate if theme actually changes
      if (animate && wasDark !== isDark) {
        const overlay = document.getElementById('theme-transition');
        if (overlay) {
          // Get button position for radial origin
          const btn = isDark ? themeDarkBtn : themeLightBtn;
          if (btn) {
            const rect = btn.getBoundingClientRect();
            overlay.style.setProperty('--x', `${rect.left + rect.width / 2}px`);
            overlay.style.setProperty('--y', `${rect.top + rect.height / 2}px`);
          }

          overlay.classList.remove('to-dark', 'to-light', 'active');
          overlay.classList.add(isDark ? 'to-dark' : 'to-light');

          // Force reflow
          void overlay.offsetWidth;

          overlay.classList.add('active');

          // Remove classes after animation
          setTimeout(() => {
            overlay.classList.remove('active', 'to-dark', 'to-light');
          }, 400);
        }
      }

      document.documentElement.classList.toggle('dark', isDark);

      try {
        localStorage.setItem('theme', theme);
      } catch (e) {}

      updateThemeButtons(theme);
    }

    function updateThemeButtons(theme: 'light' | 'dark' | 'system') {
      const activeClass = 'bg-primary text-white';
      const inactiveClass = 'hover:bg-gray-300 dark:hover:bg-slate-600';

      [themeLightBtn, themeDarkBtn, themeSystemBtn].forEach(btn => {
        btn?.classList.remove('bg-primary', 'text-white', 'hover:bg-gray-300', 'dark:hover:bg-slate-600');
      });

      if (theme === 'light') {
        themeLightBtn?.classList.add('bg-primary', 'text-white');
        themeDarkBtn?.classList.add('hover:bg-gray-300', 'dark:hover:bg-slate-600');
        themeSystemBtn?.classList.add('hover:bg-gray-300', 'dark:hover:bg-slate-600');
      } else if (theme === 'dark') {
        themeDarkBtn?.classList.add('bg-primary', 'text-white');
        themeLightBtn?.classList.add('hover:bg-gray-300', 'dark:hover:bg-slate-600');
        themeSystemBtn?.classList.add('hover:bg-gray-300', 'dark:hover:bg-slate-600');
      } else {
        themeSystemBtn?.classList.add('bg-primary', 'text-white');
        themeLightBtn?.classList.add('hover:bg-gray-300', 'dark:hover:bg-slate-600');
        themeDarkBtn?.classList.add('hover:bg-gray-300', 'dark:hover:bg-slate-600');
      }
    }

    // Initialize theme buttons state
    updateThemeButtons(getThemePreference());

    themeLightBtn?.addEventListener('click', () => applyTheme('light'));
    themeDarkBtn?.addEventListener('click', () => applyTheme('dark'));
    themeSystemBtn?.addEventListener('click', () => applyTheme('system'));

    // Listen for system theme changes when in system mode
    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
      if (getThemePreference() === 'system') {
        applyTheme('system');
      }
    });

    function openConfigPanel() {
      configPanel.classList.remove('opacity-0', 'pointer-events-none', 'translate-x-4');
      configPanel.classList.add('opacity-100', 'pointer-events-auto', 'translate-x-0');
    }

    function closeConfigPanel() {
      configPanel.classList.add('opacity-0', 'pointer-events-none', 'translate-x-4');
      configPanel.classList.remove('opacity-100', 'pointer-events-auto', 'translate-x-0');
    }

    function toggleConfigPanel() {
      if (configPanel.classList.contains('opacity-0')) {
        openConfigPanel();
      } else {
        closeConfigPanel();
      }
    }

    // Open config panel from buttons
    openBtnFloat?.addEventListener('click', (e) => {
      e.stopPropagation();
      toggleConfigPanel();
    });
    openBtnHeader?.addEventListener('click', (e) => {
      e.stopPropagation();
      toggleConfigPanel();
    });

    // Keyboard shortcut: Ctrl+Shift+G
    document.addEventListener('keydown', (e) => {
      if (e.ctrlKey && e.shiftKey && e.key === 'G') {
        e.preventDefault();
        toggleConfigPanel();
      }
    });

    closeBtn?.addEventListener('click', closeConfigPanel);

    // Close on click outside
    document.addEventListener('click', (e) => {
      const target = e.target as HTMLElement;
      if (!configPanel.contains(target) &&
          target !== openBtnFloat &&
          target !== openBtnHeader &&
          !openBtnFloat?.contains(target) &&
          !openBtnHeader?.contains(target) &&
          !configPanel.classList.contains('opacity-0')) {
        closeConfigPanel();
      }
    });

    function handleMouseMove(e: MouseEvent) {
      mouse.x = e.clientX;
      mouse.y = e.clientY;
    }

    function handleTouchMove(e: TouchEvent) {
      if (e.touches.length > 0) {
        mouse.x = e.touches[0].clientX;
        mouse.y = e.touches[0].clientY;
      }
    }

    function cleanup() {
      cancelAnimationFrame(animationId);
      window.removeEventListener('resize', handleResize);
      window.removeEventListener('mousemove', handleMouseMove);
      window.removeEventListener('touchmove', handleTouchMove);
      window.removeEventListener('scroll', updateHeaderPosition);
    }

    function handleResize() {
      resize();
      init();
    }

    // Initialize
    updateConfigUI();
    setupConfigListeners();
    init();
    animate();

    // Event listeners
    window.addEventListener('resize', handleResize);
    window.addEventListener('mousemove', handleMouseMove);
    window.addEventListener('touchmove', handleTouchMove);
    window.addEventListener('scroll', updateHeaderPosition, { passive: true });

    // Cleanup on page navigation
    document.addEventListener('astro:before-swap', cleanup, { once: true });
  }

  // Run on initial load
  initNetwork();

  // Re-run after View Transitions
  document.addEventListener('astro:after-swap', initNetwork);
</script>
