---
// Interactive network background component with hidden config
---

<div class="fixed inset-0 z-0 pointer-events-none" id="network-container">
  <canvas id="network-canvas" class="w-full h-full pointer-events-auto"></canvas>
  <div class="absolute inset-0 bg-gradient-to-b from-transparent via-white/50 to-white dark:via-slate-900/50 dark:to-slate-900"></div>
</div>

<!-- Theme transition overlay -->
<div id="theme-transition" class="theme-transition-overlay"></div>

<!-- Floating Settings Button -->
<button
  id="open-network-config"
  class="fixed bottom-4 right-4 z-40 w-10 h-10 rounded-full bg-white/80 dark:bg-slate-800/80 backdrop-blur-sm border border-gray-200 dark:border-slate-700 shadow-lg flex items-center justify-center text-muted hover:text-primary hover:scale-110 hover:shadow-xl transition-all duration-300 group"
  title="Settings (Ctrl+Shift+G)"
>
  <svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5 transition-transform duration-500 group-hover:rotate-90" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <circle cx="12" cy="12" r="3"/>
    <path d="M12 1v2M12 21v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M1 12h2M21 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42"/>
  </svg>
</button>

<!-- Hidden Config Panel -->
<div id="network-config" class="fixed top-4 right-4 z-50 opacity-0 pointer-events-none translate-x-4 transition-all duration-300 ease-out">
  <div class="bg-white/95 dark:bg-slate-800/95 backdrop-blur-md rounded-xl shadow-2xl p-4 w-72 border border-gray-200 dark:border-slate-700 max-h-[85vh] flex flex-col">
    <div class="flex justify-between items-center mb-3 flex-shrink-0">
      <h3 class="font-bold text-base">Settings</h3>
      <button id="close-config" class="text-gray-400 hover:text-gray-600 dark:hover:text-gray-200 text-xl leading-none">&times;</button>
    </div>

    <div class="space-y-3 text-xs overflow-y-auto flex-grow pr-1">
      <!-- Theme Mode -->
      <div class="border-b border-gray-200 dark:border-slate-700 pb-3">
        <h4 class="font-semibold mb-2 text-muted text-xs uppercase tracking-wide">Theme</h4>
        <div class="flex gap-1 bg-gray-200 dark:bg-slate-700 rounded-lg p-0.5">
          <button id="theme-light" class="flex-1 px-2 py-1 rounded-md transition-colors text-center" title="Light">‚òÄÔ∏è</button>
          <button id="theme-dark" class="flex-1 px-2 py-1 rounded-md transition-colors text-center" title="Dark">üåô</button>
          <button id="theme-system" class="flex-1 px-2 py-1 rounded-md transition-colors text-center" title="System">üíª</button>
        </div>
      </div>

      <!-- Physics -->
      <div class="border-b border-gray-200 dark:border-slate-700 pb-3">
        <h4 class="font-semibold mb-2 text-muted text-xs uppercase tracking-wide">Physics</h4>

        <label class="block mb-1.5">
          <span class="text-muted flex justify-between"><span>Nodes</span><span id="nodeCount-value">60</span></span>
          <input type="range" id="nodeCount" min="10" max="150" value="60" class="w-full accent-primary h-1.5">
        </label>

        <label class="block mb-1.5">
          <span class="text-muted flex justify-between"><span>Speed</span><span id="nodeSpeed-value">0.3</span></span>
          <input type="range" id="nodeSpeed" min="0.1" max="2" step="0.1" value="0.3" class="w-full accent-primary h-1.5">
        </label>

        <label class="block mb-1.5">
          <span class="text-muted flex justify-between"><span>Connection</span><span id="connectionDistance-value">150</span></span>
          <input type="range" id="connectionDistance" min="50" max="300" value="150" class="w-full accent-primary h-1.5">
        </label>

        <label class="block mb-1.5">
          <span class="text-muted flex justify-between"><span>Mouse Radius</span><span id="mouseRadius-value">200</span></span>
          <input type="range" id="mouseRadius" min="50" max="400" value="200" class="w-full accent-primary h-1.5">
        </label>

        <label class="block">
          <span class="text-muted flex justify-between"><span>Node Size</span><span id="nodeSize-value">2</span></span>
          <input type="range" id="nodeSize" min="1" max="6" step="0.5" value="2" class="w-full accent-primary h-1.5">
        </label>
      </div>

      <!-- Colors -->
      <div class="border-b border-gray-200 dark:border-slate-700 pb-3">
        <h4 class="font-semibold mb-2 text-muted text-xs uppercase tracking-wide">Colors</h4>

        <div class="grid grid-cols-3 gap-2 mb-2">
          <label class="flex flex-col items-center gap-1">
            <input type="color" id="nodeColor" value="#6366f1" class="w-8 h-6 rounded cursor-pointer">
            <span class="text-muted text-[10px]">Node</span>
          </label>
          <label class="flex flex-col items-center gap-1">
            <input type="color" id="lineColor" value="#6366f1" class="w-8 h-6 rounded cursor-pointer">
            <span class="text-muted text-[10px]">Line</span>
          </label>
          <label class="flex flex-col items-center gap-1">
            <input type="color" id="mouseLineColor" value="#6366f1" class="w-8 h-6 rounded cursor-pointer">
            <span class="text-muted text-[10px]">Mouse</span>
          </label>
        </div>

        <label class="block mb-1.5">
          <span class="text-muted flex justify-between"><span>Node Opacity</span><span id="nodeOpacity-value">0.6</span></span>
          <input type="range" id="nodeOpacity" min="0.1" max="1" step="0.1" value="0.6" class="w-full accent-primary h-1.5">
        </label>

        <label class="block">
          <span class="text-muted flex justify-between"><span>Line Opacity</span><span id="lineOpacity-value">0.15</span></span>
          <input type="range" id="lineOpacity" min="0.05" max="0.5" step="0.05" value="0.15" class="w-full accent-primary h-1.5">
        </label>
      </div>

      <!-- Presets -->
      <div class="flex-shrink-0">
        <h4 class="font-semibold mb-2 text-muted text-xs uppercase tracking-wide">Presets</h4>
        <div class="flex gap-1.5 flex-wrap">
          <button data-preset="default" class="px-2 py-0.5 text-[10px] rounded-full bg-gray-200 dark:bg-slate-700 hover:bg-primary hover:text-white transition-colors">Default</button>
          <button data-preset="dense" class="px-2 py-0.5 text-[10px] rounded-full bg-gray-200 dark:bg-slate-700 hover:bg-primary hover:text-white transition-colors">Dense</button>
          <button data-preset="minimal" class="px-2 py-0.5 text-[10px] rounded-full bg-gray-200 dark:bg-slate-700 hover:bg-primary hover:text-white transition-colors">Minimal</button>
          <button data-preset="rainbow" class="px-2 py-0.5 text-[10px] rounded-full bg-gray-200 dark:bg-slate-700 hover:bg-primary hover:text-white transition-colors">Rainbow</button>
          <button data-preset="matrix" class="px-2 py-0.5 text-[10px] rounded-full bg-gray-200 dark:bg-slate-700 hover:bg-primary hover:text-white transition-colors">Matrix</button>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
  function initNetwork() {
    const canvas = document.getElementById('network-canvas') as HTMLCanvasElement;
    const configPanel = document.getElementById('network-config');
    const openBtnFloat = document.getElementById('open-network-config');
    const openBtnHeader = document.getElementById('open-network-config-header');
    const closeBtn = document.getElementById('close-config');

    if (!canvas || !configPanel) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    let width: number;
    let height: number;
    let nodes: Array<{x: number; y: number; vx: number; vy: number; radius: number; hue?: number}> = [];
    let mouse = { x: 0, y: 0 };
    let headerCenter = { x: 0, y: 0, width: 0, height: 0 };
    let animationId: number;

    // Default config
    const defaultConfig = {
      nodeCount: 60,
      connectionDistance: 150,
      nodeSpeed: 0.3,
      mouseRadius: 200,
      nodeSize: 2,
      nodeColor: '#6366f1',
      lineColor: '#6366f1',
      mouseLineColor: '#6366f1',
      nodeOpacity: 0.6,
      lineOpacity: 0.15,
      rainbowMode: false,
    };

    // Presets
    const presets: Record<string, Partial<typeof defaultConfig>> = {
      default: { ...defaultConfig },
      dense: { nodeCount: 120, connectionDistance: 100, nodeSpeed: 0.2, nodeSize: 1.5 },
      minimal: { nodeCount: 25, connectionDistance: 200, nodeSpeed: 0.15, nodeSize: 3, lineOpacity: 0.1 },
      rainbow: { rainbowMode: true, nodeCount: 80, nodeOpacity: 0.8, lineOpacity: 0.25 },
      matrix: { nodeColor: '#00ff00', lineColor: '#00ff00', mouseLineColor: '#00ff00', nodeCount: 100, nodeSpeed: 0.5, lineOpacity: 0.2 },
    };

    // Load saved config or use defaults
    let config = { ...defaultConfig };
    try {
      const saved = localStorage.getItem('networkConfig');
      if (saved) {
        config = { ...defaultConfig, ...JSON.parse(saved) };
      }
    } catch (e) {}

    function saveConfig() {
      try {
        localStorage.setItem('networkConfig', JSON.stringify(config));
      } catch (e) {}
    }

    function hexToRgba(hex: string, alpha: number): string {
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    function hslToRgba(h: number, s: number, l: number, a: number): string {
      const c = (1 - Math.abs(2 * l - 1)) * s;
      const x = c * (1 - Math.abs((h / 60) % 2 - 1));
      const m = l - c / 2;
      let r = 0, g = 0, b = 0;
      if (h < 60) { r = c; g = x; }
      else if (h < 120) { r = x; g = c; }
      else if (h < 180) { g = c; b = x; }
      else if (h < 240) { g = x; b = c; }
      else if (h < 300) { r = x; b = c; }
      else { r = c; b = x; }
      return `rgba(${Math.round((r + m) * 255)}, ${Math.round((g + m) * 255)}, ${Math.round((b + m) * 255)}, ${a})`;
    }

    function init() {
      resize();
      nodes = [];
      for (let i = 0; i < config.nodeCount; i++) {
        nodes.push({
          x: Math.random() * width,
          y: Math.random() * height,
          vx: (Math.random() - 0.5) * config.nodeSpeed,
          vy: (Math.random() - 0.5) * config.nodeSpeed,
          radius: Math.random() * config.nodeSize + 1,
          hue: Math.random() * 360,
        });
      }
    }

    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
      updateHeaderPosition();
    }

    function updateHeaderPosition() {
      const header = document.querySelector('h1');
      if (header) {
        const rect = header.getBoundingClientRect();
        headerCenter = {
          x: rect.left + rect.width / 2,
          y: rect.top + rect.height / 2,
          width: rect.width,
          height: rect.height
        };
      }
    }

    function animate() {
      ctx.clearRect(0, 0, width, height);

      nodes.forEach((node, i) => {
        node.x += node.vx;
        node.y += node.vy;

        if (node.x < 0 || node.x > width) node.vx *= -1;
        if (node.y < 0 || node.y > height) node.vy *= -1;

        node.x = Math.max(0, Math.min(width, node.x));
        node.y = Math.max(0, Math.min(height, node.y));

        // Update hue for rainbow mode
        if (config.rainbowMode && node.hue !== undefined) {
          node.hue = (node.hue + 0.5) % 360;
        }

        // Draw node
        ctx.beginPath();
        ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);
        ctx.fillStyle = config.rainbowMode
          ? hslToRgba(node.hue!, 0.7, 0.5, config.nodeOpacity)
          : hexToRgba(config.nodeColor, config.nodeOpacity);
        ctx.fill();

        // Connect to nearby nodes
        for (let j = i + 1; j < nodes.length; j++) {
          const other = nodes[j];
          const dx = node.x - other.x;
          const dy = node.y - other.y;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (dist < config.connectionDistance) {
            ctx.beginPath();
            ctx.moveTo(node.x, node.y);
            ctx.lineTo(other.x, other.y);
            const opacity = config.lineOpacity * (1 - dist / config.connectionDistance);
            ctx.strokeStyle = config.rainbowMode
              ? hslToRgba((node.hue! + other.hue!) / 2, 0.7, 0.5, opacity)
              : hexToRgba(config.lineColor, opacity);
            ctx.lineWidth = 1;
            ctx.stroke();
          }
        }

        // Connect to mouse
        const dx = node.x - mouse.x;
        const dy = node.y - mouse.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < config.mouseRadius) {
          ctx.beginPath();
          ctx.moveTo(node.x, node.y);
          ctx.lineTo(mouse.x, mouse.y);
          const opacity = 0.3 * (1 - dist / config.mouseRadius);
          ctx.strokeStyle = config.rainbowMode
            ? hslToRgba(node.hue!, 0.7, 0.5, opacity)
            : hexToRgba(config.mouseLineColor, opacity);
          ctx.lineWidth = 1;
          ctx.stroke();
        }

        // Connect to header
        if (headerCenter.x > 0) {
          const headerRadius = config.mouseRadius * 1.5;
          // Calculate distance to nearest point on header rectangle
          const closestX = Math.max(headerCenter.x - headerCenter.width / 2, Math.min(node.x, headerCenter.x + headerCenter.width / 2));
          const closestY = Math.max(headerCenter.y - headerCenter.height / 2, Math.min(node.y, headerCenter.y + headerCenter.height / 2));
          const hdx = node.x - closestX;
          const hdy = node.y - closestY;
          const hdist = Math.sqrt(hdx * hdx + hdy * hdy);

          if (hdist < headerRadius && hdist > 0) {
            ctx.beginPath();
            ctx.moveTo(node.x, node.y);
            ctx.lineTo(closestX, closestY);
            const opacity = 0.25 * (1 - hdist / headerRadius);
            ctx.strokeStyle = config.rainbowMode
              ? hslToRgba(node.hue!, 0.7, 0.5, opacity)
              : hexToRgba(config.nodeColor, opacity);
            ctx.lineWidth = 1;
            ctx.stroke();
          }
        }
      });

      animationId = requestAnimationFrame(animate);
    }

    function updateConfigUI() {
      const elements: Record<string, HTMLInputElement> = {};
      ['nodeCount', 'nodeSpeed', 'connectionDistance', 'mouseRadius', 'nodeSize',
       'nodeColor', 'lineColor', 'mouseLineColor', 'nodeOpacity', 'lineOpacity'].forEach(id => {
        elements[id] = document.getElementById(id) as HTMLInputElement;
        const valueEl = document.getElementById(`${id}-value`);
        if (elements[id]) {
          elements[id].value = String(config[id as keyof typeof config]);
          if (valueEl) valueEl.textContent = String(config[id as keyof typeof config]);
        }
      });
    }

    function setupConfigListeners() {
      ['nodeCount', 'nodeSpeed', 'connectionDistance', 'mouseRadius', 'nodeSize',
       'nodeOpacity', 'lineOpacity'].forEach(id => {
        const el = document.getElementById(id) as HTMLInputElement;
        const valueEl = document.getElementById(`${id}-value`);
        if (el) {
          el.addEventListener('input', () => {
            const val = parseFloat(el.value);
            (config as any)[id] = val;
            if (valueEl) valueEl.textContent = String(val);
            if (id === 'nodeCount' || id === 'nodeSize') init();
            saveConfig();
          });
        }
      });

      ['nodeColor', 'lineColor', 'mouseLineColor'].forEach(id => {
        const el = document.getElementById(id) as HTMLInputElement;
        if (el) {
          el.addEventListener('input', () => {
            (config as any)[id] = el.value;
            config.rainbowMode = false;
            saveConfig();
          });
        }
      });

      // Presets
      document.querySelectorAll('[data-preset]').forEach(btn => {
        btn.addEventListener('click', () => {
          const presetName = (btn as HTMLElement).dataset.preset!;
          const preset = presets[presetName];
          if (preset) {
            Object.assign(config, { ...defaultConfig, ...preset });
            updateConfigUI();
            init();
            saveConfig();
          }
        });
      });
    }

    // Theme toggle functionality
    const themeLightBtn = document.getElementById('theme-light');
    const themeDarkBtn = document.getElementById('theme-dark');
    const themeSystemBtn = document.getElementById('theme-system');

    function getThemePreference(): 'light' | 'dark' | 'system' {
      try {
        return (localStorage.getItem('theme') as 'light' | 'dark' | 'system') || 'system';
      } catch (e) {
        return 'system';
      }
    }

    function applyTheme(theme: 'light' | 'dark' | 'system', animate = true) {
      const wasDark = document.documentElement.classList.contains('dark');
      const isDark = theme === 'dark' ||
        (theme === 'system' && window.matchMedia('(prefers-color-scheme: dark)').matches);

      // Only animate if theme actually changes
      if (animate && wasDark !== isDark) {
        const overlay = document.getElementById('theme-transition');
        if (overlay) {
          // Get button position for radial origin
          const btn = isDark ? themeDarkBtn : themeLightBtn;
          if (btn) {
            const rect = btn.getBoundingClientRect();
            overlay.style.setProperty('--x', `${rect.left + rect.width / 2}px`);
            overlay.style.setProperty('--y', `${rect.top + rect.height / 2}px`);
          }

          overlay.classList.remove('to-dark', 'to-light', 'active');
          overlay.classList.add(isDark ? 'to-dark' : 'to-light');

          // Force reflow
          void overlay.offsetWidth;

          overlay.classList.add('active');

          // Remove classes after animation
          setTimeout(() => {
            overlay.classList.remove('active', 'to-dark', 'to-light');
          }, 400);
        }
      }

      document.documentElement.classList.toggle('dark', isDark);

      try {
        localStorage.setItem('theme', theme);
      } catch (e) {}

      updateThemeButtons(theme);
    }

    function updateThemeButtons(theme: 'light' | 'dark' | 'system') {
      const activeClass = 'bg-primary text-white';
      const inactiveClass = 'hover:bg-gray-300 dark:hover:bg-slate-600';

      [themeLightBtn, themeDarkBtn, themeSystemBtn].forEach(btn => {
        btn?.classList.remove('bg-primary', 'text-white', 'hover:bg-gray-300', 'dark:hover:bg-slate-600');
      });

      if (theme === 'light') {
        themeLightBtn?.classList.add('bg-primary', 'text-white');
        themeDarkBtn?.classList.add('hover:bg-gray-300', 'dark:hover:bg-slate-600');
        themeSystemBtn?.classList.add('hover:bg-gray-300', 'dark:hover:bg-slate-600');
      } else if (theme === 'dark') {
        themeDarkBtn?.classList.add('bg-primary', 'text-white');
        themeLightBtn?.classList.add('hover:bg-gray-300', 'dark:hover:bg-slate-600');
        themeSystemBtn?.classList.add('hover:bg-gray-300', 'dark:hover:bg-slate-600');
      } else {
        themeSystemBtn?.classList.add('bg-primary', 'text-white');
        themeLightBtn?.classList.add('hover:bg-gray-300', 'dark:hover:bg-slate-600');
        themeDarkBtn?.classList.add('hover:bg-gray-300', 'dark:hover:bg-slate-600');
      }
    }

    // Initialize theme buttons state
    updateThemeButtons(getThemePreference());

    themeLightBtn?.addEventListener('click', () => applyTheme('light'));
    themeDarkBtn?.addEventListener('click', () => applyTheme('dark'));
    themeSystemBtn?.addEventListener('click', () => applyTheme('system'));

    // Listen for system theme changes when in system mode
    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
      if (getThemePreference() === 'system') {
        applyTheme('system');
      }
    });

    function openConfigPanel() {
      configPanel.classList.remove('opacity-0', 'pointer-events-none', 'translate-x-4');
      configPanel.classList.add('opacity-100', 'pointer-events-auto', 'translate-x-0');
    }

    function closeConfigPanel() {
      configPanel.classList.add('opacity-0', 'pointer-events-none', 'translate-x-4');
      configPanel.classList.remove('opacity-100', 'pointer-events-auto', 'translate-x-0');
    }

    function toggleConfigPanel() {
      if (configPanel.classList.contains('opacity-0')) {
        openConfigPanel();
      } else {
        closeConfigPanel();
      }
    }

    // Open config panel from buttons
    openBtnFloat?.addEventListener('click', (e) => {
      e.stopPropagation();
      toggleConfigPanel();
    });
    openBtnHeader?.addEventListener('click', (e) => {
      e.stopPropagation();
      toggleConfigPanel();
    });

    // Keyboard shortcut: Ctrl+Shift+G
    document.addEventListener('keydown', (e) => {
      if (e.ctrlKey && e.shiftKey && e.key === 'G') {
        e.preventDefault();
        toggleConfigPanel();
      }
    });

    closeBtn?.addEventListener('click', closeConfigPanel);

    // Close on click outside
    document.addEventListener('click', (e) => {
      const target = e.target as HTMLElement;
      if (!configPanel.contains(target) &&
          target !== openBtnFloat &&
          target !== openBtnHeader &&
          !openBtnFloat?.contains(target) &&
          !openBtnHeader?.contains(target) &&
          !configPanel.classList.contains('opacity-0')) {
        closeConfigPanel();
      }
    });

    function handleMouseMove(e: MouseEvent) {
      mouse.x = e.clientX;
      mouse.y = e.clientY;
    }

    function handleTouchMove(e: TouchEvent) {
      if (e.touches.length > 0) {
        mouse.x = e.touches[0].clientX;
        mouse.y = e.touches[0].clientY;
      }
    }

    function cleanup() {
      cancelAnimationFrame(animationId);
      window.removeEventListener('resize', handleResize);
      window.removeEventListener('mousemove', handleMouseMove);
      window.removeEventListener('touchmove', handleTouchMove);
      window.removeEventListener('scroll', updateHeaderPosition);
    }

    function handleResize() {
      resize();
      init();
    }

    // Initialize
    updateConfigUI();
    setupConfigListeners();
    init();
    animate();

    // Event listeners
    window.addEventListener('resize', handleResize);
    window.addEventListener('mousemove', handleMouseMove);
    window.addEventListener('touchmove', handleTouchMove);
    window.addEventListener('scroll', updateHeaderPosition, { passive: true });

    // Cleanup on page navigation
    document.addEventListener('astro:before-swap', cleanup, { once: true });
  }

  // Run on initial load
  initNetwork();

  // Re-run after View Transitions
  document.addEventListener('astro:after-swap', initNetwork);
</script>
