---
// Interactive network background component with hidden config
---

<div class="fixed inset-0 z-0 pointer-events-none" id="network-container">
  <canvas id="network-canvas" class="w-full h-full pointer-events-auto"></canvas>
  <div class="absolute inset-0 bg-gradient-to-b from-transparent via-white/50 to-white dark:via-slate-900/50 dark:to-slate-900"></div>
</div>

<!-- Theme transition overlay -->
<div id="theme-transition" class="theme-transition-overlay"></div>

<!-- Snake Game Intro Overlay -->
<div id="snake-intro" class="fixed inset-0 z-[60] flex items-center justify-center opacity-0 pointer-events-none transition-opacity duration-300">
  <div class="absolute inset-0 bg-black/70 backdrop-blur-sm"></div>
  <div class="relative z-10 text-center px-6 max-w-md">
    <!-- Intro Screen -->
    <div id="snake-intro-content" class="transform scale-95 opacity-0 transition-all duration-300">
      <div class="text-6xl mb-4">üêç</div>
      <h2 class="text-4xl font-bold text-white mb-4">Snake</h2>
      <div class="bg-white/10 backdrop-blur rounded-xl p-6 mb-6 text-left">
        <h3 class="text-lg font-semibold text-white mb-3">How to Play</h3>
        <ul class="text-gray-200 space-y-2 text-sm">
          <li class="flex items-center gap-2">
            <span class="text-green-400">‚Üí</span>
            Use <kbd class="px-2 py-0.5 bg-white/20 rounded text-xs">WASD</kbd>, <kbd class="px-2 py-0.5 bg-white/20 rounded text-xs">Arrow Keys</kbd>, swipe gestures, or on-screen controls
          </li>
          <li class="flex items-center gap-2">
            <span class="text-green-400">‚Üí</span>
            Eat the floating nodes to grow
          </li>
          <li class="flex items-center gap-2">
            <span class="text-green-400">‚Üí</span>
            Avoid walls and yourself
          </li>
          <li class="flex items-center gap-2">
            <span class="text-green-400">‚Üí</span>
            Press <kbd class="px-2 py-0.5 bg-white/20 rounded text-xs">ESC</kbd> or tap quit to exit
          </li>
        </ul>
      </div>
      <button id="snake-ready-btn" class="px-8 py-3 bg-green-500 hover:bg-green-400 text-white font-bold text-lg rounded-full transition-all duration-300 hover:scale-105 hover:shadow-lg hover:shadow-green-500/30">
        Ready!
      </button>
    </div>

    <!-- Countdown -->
    <div id="snake-countdown" class="hidden">
      <div id="snake-countdown-number" class="text-9xl font-bold text-white animate-pulse"></div>
    </div>
  </div>
</div>

<!-- Snake Game HUD -->
<div id="snake-hud" class="fixed top-4 left-1/2 -translate-x-1/2 z-50 opacity-0 pointer-events-none transition-opacity duration-300">
  <div class="bg-black/50 backdrop-blur-sm rounded-full px-6 py-2 flex items-center gap-6 text-white">
    <div class="flex items-center gap-2">
      <span class="text-lg">üêç</span>
      <span class="text-sm text-gray-300">Score:</span>
      <span id="snake-hud-score" class="font-bold text-green-400 text-lg">0</span>
    </div>
    <div class="w-px h-4 bg-white/20"></div>
    <div class="flex items-center gap-2">
      <span class="text-sm text-gray-300">Best:</span>
      <span id="snake-hud-high" class="font-bold text-yellow-400">0</span>
    </div>
    <div class="w-px h-4 bg-white/20"></div>
    <button id="snake-hud-quit" class="text-xs text-gray-400 hover:text-red-400 transition-colors">
      ESC to quit
    </button>
  </div>
</div>

<!-- Mobile Controls (D-Pad) -->
<div id="snake-mobile-controls" class="fixed bottom-8 left-1/2 -translate-x-1/2 z-50 opacity-0 pointer-events-none transition-opacity duration-300">
  <div class="relative w-40 h-40">
    <!-- Up -->
    <button id="snake-btn-up" class="absolute top-0 left-1/2 -translate-x-1/2 w-12 h-12 bg-green-500/80 hover:bg-green-400 active:bg-green-600 backdrop-blur-sm rounded-lg shadow-lg flex items-center justify-center text-white text-2xl font-bold transition-all active:scale-95">
      ‚ñ≤
    </button>
    <!-- Left -->
    <button id="snake-btn-left" class="absolute top-1/2 -translate-y-1/2 left-0 w-12 h-12 bg-green-500/80 hover:bg-green-400 active:bg-green-600 backdrop-blur-sm rounded-lg shadow-lg flex items-center justify-center text-white text-2xl font-bold transition-all active:scale-95">
      ‚óÄ
    </button>
    <!-- Right -->
    <button id="snake-btn-right" class="absolute top-1/2 -translate-y-1/2 right-0 w-12 h-12 bg-green-500/80 hover:bg-green-400 active:bg-green-600 backdrop-blur-sm rounded-lg shadow-lg flex items-center justify-center text-white text-2xl font-bold transition-all active:scale-95">
      ‚ñ∂
    </button>
    <!-- Down -->
    <button id="snake-btn-down" class="absolute bottom-0 left-1/2 -translate-x-1/2 w-12 h-12 bg-green-500/80 hover:bg-green-400 active:bg-green-600 backdrop-blur-sm rounded-lg shadow-lg flex items-center justify-center text-white text-2xl font-bold transition-all active:scale-95">
      ‚ñº
    </button>
    <!-- Center (just for visual balance) -->
    <div class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-8 h-8 bg-black/30 backdrop-blur-sm rounded-full"></div>
  </div>
</div>

<!-- Floating Buttons -->
<div class="fixed bottom-4 right-4 z-40 flex gap-2">
  <!-- Snake Button -->
  <button
    id="play-snake-float"
    class="w-10 h-10 rounded-full bg-white/80 dark:bg-slate-800/80 backdrop-blur-sm border border-gray-200 dark:border-slate-700 shadow-lg flex items-center justify-center hover:bg-green-500 hover:text-white hover:border-green-500 hover:scale-110 hover:shadow-xl transition-all duration-300 group"
    title="Play Snake"
  >
    <span class="text-lg group-hover:animate-bounce">üêç</span>
  </button>

  <!-- Settings Button -->
  <button
    id="open-network-config"
    class="w-10 h-10 rounded-full bg-white/80 dark:bg-slate-800/80 backdrop-blur-sm border border-gray-200 dark:border-slate-700 shadow-lg flex items-center justify-center text-muted hover:text-primary hover:scale-110 hover:shadow-xl transition-all duration-300 group"
    title="Settings (Ctrl+Shift+G)"
  >
    <svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5 transition-transform duration-500 group-hover:rotate-90" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="3"/>
      <path d="M12 1v2M12 21v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M1 12h2M21 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42"/>
    </svg>
  </button>
</div>

<!-- Hidden Config Panel -->
<div id="network-config" class="fixed top-4 right-4 z-50 opacity-0 pointer-events-none translate-x-4 transition-all duration-300 ease-out">
  <div class="bg-white/95 dark:bg-slate-800/95 backdrop-blur-md rounded-xl shadow-2xl p-4 w-72 border border-gray-200 dark:border-slate-700 max-h-[85vh] flex flex-col">
    <div class="flex justify-between items-center mb-3 flex-shrink-0">
      <h3 class="font-bold text-base">Settings</h3>
      <button id="close-config" class="text-gray-400 hover:text-gray-600 dark:hover:text-gray-200 text-xl leading-none">&times;</button>
    </div>

    <div class="space-y-3 text-xs overflow-y-auto flex-grow pr-1">
      <!-- Theme Mode -->
      <div class="border-b border-gray-200 dark:border-slate-700 pb-3">
        <h4 class="font-semibold mb-2 text-muted text-xs uppercase tracking-wide">Theme</h4>
        <div class="flex gap-1 bg-gray-200 dark:bg-slate-700 rounded-lg p-0.5">
          <button id="theme-light" class="flex-1 px-2 py-1 rounded-md transition-colors text-center" title="Light">‚òÄÔ∏è</button>
          <button id="theme-dark" class="flex-1 px-2 py-1 rounded-md transition-colors text-center" title="Dark">üåô</button>
          <button id="theme-system" class="flex-1 px-2 py-1 rounded-md transition-colors text-center" title="System">üíª</button>
        </div>
      </div>

      <!-- Nodes -->
      <div class="border-b border-gray-200 dark:border-slate-700 pb-3">
        <h4 class="font-semibold mb-2 text-muted text-xs uppercase tracking-wide">Nodes</h4>

        <label class="block mb-1.5">
          <span class="text-muted flex justify-between"><span>Count</span><span id="nodeCount-value">60</span></span>
          <input type="range" id="nodeCount" min="10" max="150" value="60" class="w-full accent-primary h-1.5">
        </label>

        <label class="block mb-1.5">
          <span class="text-muted flex justify-between"><span>Size</span><span id="nodeSize-value">2</span></span>
          <input type="range" id="nodeSize" min="1" max="6" step="0.5" value="2" class="w-full accent-primary h-1.5">
        </label>

        <label class="block mb-1.5">
          <span class="text-muted flex justify-between"><span>Speed</span><span id="nodeSpeed-value">0.3</span></span>
          <input type="range" id="nodeSpeed" min="0.1" max="2" step="0.1" value="0.3" class="w-full accent-primary h-1.5">
        </label>

        <div class="flex items-center gap-2 mb-1.5">
          <label class="flex flex-col items-center gap-1">
            <input type="color" id="nodeColor" value="#6366f1" class="w-8 h-6 rounded cursor-pointer">
            <span class="text-muted text-[10px]">Color</span>
          </label>
          <label class="flex-1">
            <span class="text-muted flex justify-between"><span>Opacity</span><span id="nodeOpacity-value">0.6</span></span>
            <input type="range" id="nodeOpacity" min="0.1" max="1" step="0.1" value="0.6" class="w-full accent-primary h-1.5">
          </label>
        </div>
      </div>

      <!-- Node-to-Node Edges -->
      <div class="border-b border-gray-200 dark:border-slate-700 pb-3">
        <div class="flex items-center justify-between mb-2">
          <h4 class="font-semibold text-muted text-xs uppercase tracking-wide">Node Edges</h4>
          <label class="flex items-center gap-1 cursor-pointer">
            <input type="checkbox" id="nodeEdgesEnabled" checked class="accent-primary w-3 h-3">
            <span class="text-[10px] text-muted">On</span>
          </label>
        </div>

        <label class="block mb-1.5">
          <span class="text-muted flex justify-between"><span>Distance</span><span id="connectionDistance-value">150</span></span>
          <input type="range" id="connectionDistance" min="50" max="300" value="150" class="w-full accent-primary h-1.5">
        </label>

        <div class="flex items-center gap-2">
          <label class="flex flex-col items-center gap-1">
            <input type="color" id="lineColor" value="#6366f1" class="w-8 h-6 rounded cursor-pointer">
            <span class="text-muted text-[10px]">Color</span>
          </label>
          <label class="flex-1">
            <span class="text-muted flex justify-between"><span>Opacity</span><span id="lineOpacity-value">0.15</span></span>
            <input type="range" id="lineOpacity" min="0.05" max="0.5" step="0.05" value="0.15" class="w-full accent-primary h-1.5">
          </label>
        </div>
      </div>

      <!-- Mouse Edges -->
      <div class="border-b border-gray-200 dark:border-slate-700 pb-3">
        <div class="flex items-center justify-between mb-2">
          <h4 class="font-semibold text-muted text-xs uppercase tracking-wide">Mouse Edges</h4>
          <label class="flex items-center gap-1 cursor-pointer">
            <input type="checkbox" id="mouseEdgesEnabled" checked class="accent-primary w-3 h-3">
            <span class="text-[10px] text-muted">On</span>
          </label>
        </div>

        <label class="block mb-1.5">
          <span class="text-muted flex justify-between"><span>Radius</span><span id="mouseRadius-value">200</span></span>
          <input type="range" id="mouseRadius" min="50" max="400" value="200" class="w-full accent-primary h-1.5">
        </label>

        <div class="flex items-center gap-2 mb-1.5">
          <label class="flex flex-col items-center gap-1">
            <input type="color" id="mouseLineColor" value="#6366f1" class="w-8 h-6 rounded cursor-pointer">
            <span class="text-muted text-[10px]">Color</span>
          </label>
          <label class="flex items-center gap-1 cursor-pointer">
            <input type="checkbox" id="mouseLightning" checked class="accent-primary w-3 h-3">
            <span class="text-[10px] text-muted">Lightning</span>
          </label>
        </div>
      </div>

      <!-- Header Edges -->
      <div class="border-b border-gray-200 dark:border-slate-700 pb-3">
        <div class="flex items-center justify-between mb-2">
          <h4 class="font-semibold text-muted text-xs uppercase tracking-wide">Header Edges</h4>
          <label class="flex items-center gap-1 cursor-pointer">
            <input type="checkbox" id="headerEdgesEnabled" checked class="accent-primary w-3 h-3">
            <span class="text-[10px] text-muted">On</span>
          </label>
        </div>

        <label class="block mb-1.5">
          <span class="text-muted flex justify-between"><span>Radius</span><span id="headerRadius-value">300</span></span>
          <input type="range" id="headerRadius" min="100" max="500" value="300" class="w-full accent-primary h-1.5">
        </label>

        <div class="flex items-center gap-2 mb-1.5">
          <label class="flex flex-col items-center gap-1">
            <input type="color" id="headerLineColor" value="#6366f1" class="w-8 h-6 rounded cursor-pointer">
            <span class="text-muted text-[10px]">Color</span>
          </label>
          <label class="flex items-center gap-1 cursor-pointer">
            <input type="checkbox" id="headerLightning" checked class="accent-primary w-3 h-3">
            <span class="text-[10px] text-muted">Lightning</span>
          </label>
        </div>
      </div>

      <!-- Lightning Physics -->
      <div class="border-b border-gray-200 dark:border-slate-700 pb-3">
        <h4 class="font-semibold mb-2 text-muted text-xs uppercase tracking-wide">Lightning</h4>

        <label class="block mb-1.5">
          <span class="text-muted flex justify-between"><span>Jitter</span><span id="lightningJitter-value">0.15</span></span>
          <input type="range" id="lightningJitter" min="0.05" max="0.4" step="0.05" value="0.15" class="w-full accent-primary h-1.5">
        </label>

        <label class="block mb-1.5">
          <span class="text-muted flex justify-between"><span>Segments</span><span id="lightningSegments-value">20</span></span>
          <input type="range" id="lightningSegments" min="10" max="40" step="5" value="20" class="w-full accent-primary h-1.5">
        </label>

        <label class="block">
          <span class="text-muted flex justify-between"><span>Glow</span><span id="lightningGlow-value">4</span></span>
          <input type="range" id="lightningGlow" min="1" max="8" step="0.5" value="4" class="w-full accent-primary h-1.5">
        </label>
      </div>

      <!-- Pulse Effect -->
      <div class="border-b border-gray-200 dark:border-slate-700 pb-3">
        <div class="flex items-center justify-between mb-2">
          <h4 class="font-semibold text-muted text-xs uppercase tracking-wide">Pulse</h4>
          <label class="flex items-center gap-1 cursor-pointer">
            <input type="checkbox" id="pulseEnabled" checked class="accent-primary w-3 h-3">
            <span class="text-[10px] text-muted">On</span>
          </label>
        </div>

        <div class="flex items-center gap-2 mb-1.5">
          <label class="flex items-center gap-1 cursor-pointer">
            <input type="checkbox" id="pulseAuto" checked class="accent-primary w-3 h-3">
            <span class="text-[10px] text-muted">Auto</span>
          </label>
          <button id="pulseTrigger" class="px-2 py-0.5 text-[10px] rounded-full bg-gray-200 dark:bg-slate-700 hover:bg-primary hover:text-white transition-colors">Pulse!</button>
        </div>

        <label class="block mb-1.5">
          <span class="text-muted flex justify-between"><span>Speed</span><span id="pulseSpeed-value">10</span></span>
          <input type="range" id="pulseSpeed" min="0" max="100" step="5" value="10" class="w-full accent-primary h-1.5">
        </label>

        <label class="block mb-1.5">
          <span class="text-muted flex justify-between"><span>Width</span><span id="pulseWidth-value">40</span></span>
          <input type="range" id="pulseWidth" min="20" max="200" step="10" value="40" class="w-full accent-primary h-1.5">
        </label>

        <label class="block mb-1.5">
          <span class="text-muted flex justify-between"><span>Intensity</span><span id="pulseIntensity-value">1</span></span>
          <input type="range" id="pulseIntensity" min="0.3" max="2" step="0.1" value="1" class="w-full accent-primary h-1.5">
        </label>

        <label class="block mb-1.5">
          <span class="text-muted flex justify-between"><span>Interval</span><span id="pulseInterval-value">4</span>s</span>
          <input type="range" id="pulseInterval" min="0.5" max="5" step="0.5" value="4" class="w-full accent-primary h-1.5">
        </label>

        <div class="flex items-center gap-2">
          <label class="flex flex-col items-center gap-1">
            <input type="color" id="pulseColor" value="#ff6b6b" class="w-8 h-6 rounded cursor-pointer">
            <span class="text-muted text-[10px]">Color</span>
          </label>
          <label class="flex items-center gap-1 cursor-pointer">
            <input type="checkbox" id="pulseShake" class="accent-primary w-3 h-3">
            <span class="text-[10px] text-muted">Shake nodes</span>
          </label>
        </div>
      </div>

      <!-- Presets -->
      <div class="flex-shrink-0">
        <h4 class="font-semibold mb-2 text-muted text-xs uppercase tracking-wide">Presets</h4>
        <div class="flex gap-1.5 flex-wrap">
          <button data-preset="default" class="px-2 py-0.5 text-[10px] rounded-full bg-gray-200 dark:bg-slate-700 hover:bg-primary hover:text-white transition-colors">Default</button>
          <button data-preset="dense" class="px-2 py-0.5 text-[10px] rounded-full bg-gray-200 dark:bg-slate-700 hover:bg-primary hover:text-white transition-colors">Dense</button>
          <button data-preset="minimal" class="px-2 py-0.5 text-[10px] rounded-full bg-gray-200 dark:bg-slate-700 hover:bg-primary hover:text-white transition-colors">Minimal</button>
          <button data-preset="electric" class="px-2 py-0.5 text-[10px] rounded-full bg-gray-200 dark:bg-slate-700 hover:bg-primary hover:text-white transition-colors">Electric</button>
          <button data-preset="heartbeat" class="px-2 py-0.5 text-[10px] rounded-full bg-gray-200 dark:bg-slate-700 hover:bg-primary hover:text-white transition-colors">Heartbeat</button>
          <button data-preset="rainbow" class="px-2 py-0.5 text-[10px] rounded-full bg-gray-200 dark:bg-slate-700 hover:bg-primary hover:text-white transition-colors">Rainbow</button>
          <button data-preset="matrix" class="px-2 py-0.5 text-[10px] rounded-full bg-gray-200 dark:bg-slate-700 hover:bg-primary hover:text-white transition-colors">Matrix</button>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
  function initNetwork() {
    const canvas = document.getElementById('network-canvas') as HTMLCanvasElement;
    const configPanel = document.getElementById('network-config');
    const openBtnFloat = document.getElementById('open-network-config');
    const openBtnHeader = document.getElementById('open-network-config-header');
    const closeBtn = document.getElementById('close-config');

    if (!canvas || !configPanel) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    let width: number;
    let height: number;
    let nodes: Array<{x: number; y: number; vx: number; vy: number; radius: number; hue?: number; shakeX?: number; shakeY?: number}> = [];
    let mouse = { x: 0, y: 0 };
    let headings: Array<{ x: number; y: number; width: number; height: number }> = [];
    let animationId: number;

    // Pulse waves: each pulse expands outward from origin
    let pulseWaves: Array<{x: number; y: number; radius: number; startTime: number; maxRadius: number}> = [];
    let lastPulseTime = 0;

    // Snake game state
    let snakeActive = false;
    let snake: Array<{x: number; y: number}> = [];
    let snakeDirection = { x: 1, y: 0 };
    let snakeNextDirection = { x: 1, y: 0 };
    let snakeSpeed = 100; // ms between moves
    let lastSnakeMove = 0;
    let snakeScore = 0;
    let snakeHighScore = 0;
    let snakeSegmentSize = 15;
    let snakeGameOver = false;
    let gameOverTime = 0;

    // Touch/swipe tracking for mobile controls
    let touchStartX = 0;
    let touchStartY = 0;
    let touchEndX = 0;
    let touchEndY = 0;
    const minSwipeDistance = 30; // minimum distance for a swipe

    // Load high score
    try {
      const savedHighScore = localStorage.getItem('snakeHighScore');
      if (savedHighScore) snakeHighScore = parseInt(savedHighScore, 10);
    } catch (e) {}

    // Default config
    const defaultConfig = {
      // Nodes
      nodeCount: 60,
      nodeSize: 2,
      nodeSpeed: 0.3,
      nodeColor: '#6366f1',
      nodeOpacity: 0.6,
      // Node edges
      nodeEdgesEnabled: true,
      connectionDistance: 150,
      lineColor: '#6366f1',
      lineOpacity: 0.15,
      // Mouse edges
      mouseEdgesEnabled: true,
      mouseRadius: 200,
      mouseLineColor: '#6366f1',
      mouseLightning: true,
      // Header edges
      headerEdgesEnabled: true,
      headerRadius: 300,
      headerLineColor: '#6366f1',
      headerLightning: true,
      // Lightning physics
      lightningJitter: 0.15,
      lightningSegments: 20,
      lightningGlow: 4,
      // Pulse effect
      pulseEnabled: true,
      pulseAuto: true,
      pulseSpeed: 10,
      pulseWidth: 40,
      pulseIntensity: 1,
      pulseInterval: 4,
      pulseColor: '#ff6b6b',
      pulseShake: false,
      // Mode
      rainbowMode: false,
    };

    // Presets
    const presets: Record<string, Partial<typeof defaultConfig>> = {
      default: { ...defaultConfig },
      dense: { nodeCount: 120, connectionDistance: 100, nodeSpeed: 0.2, nodeSize: 1.5 },
      minimal: { nodeCount: 25, connectionDistance: 200, nodeSpeed: 0.15, nodeSize: 3, lineOpacity: 0.1, mouseLightning: false, headerLightning: false, pulseEnabled: false },
      electric: { lightningJitter: 0.3, lightningGlow: 6, mouseLightning: true, headerLightning: true, mouseLineColor: '#00d4ff', headerLineColor: '#00d4ff', pulseColor: '#00d4ff', pulseIntensity: 1.5 },
      heartbeat: { pulseEnabled: true, pulseAuto: true, pulseInterval: 0.8, pulseSpeed: 80, pulseWidth: 60, pulseIntensity: 1.5, pulseShake: true, pulseColor: '#ff4757', mouseLightning: false, headerLightning: false },
      rainbow: { rainbowMode: true, nodeCount: 80, nodeOpacity: 0.8, lineOpacity: 0.25, lightningJitter: 0.2 },
      matrix: { nodeColor: '#00ff00', lineColor: '#00ff00', mouseLineColor: '#00ff00', headerLineColor: '#00ff00', nodeCount: 100, nodeSpeed: 0.5, lineOpacity: 0.2, lightningJitter: 0.25, pulseColor: '#00ff00' },
    };

    // Load saved config or use defaults
    let config = { ...defaultConfig };
    try {
      const saved = localStorage.getItem('networkConfig');
      if (saved) {
        config = { ...defaultConfig, ...JSON.parse(saved) };
      }
    } catch (e) {}

    function saveConfig() {
      try {
        localStorage.setItem('networkConfig', JSON.stringify(config));
      } catch (e) {}
    }

    function hexToRgba(hex: string, alpha: number): string {
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    function hslToRgba(h: number, s: number, l: number, a: number): string {
      const c = (1 - Math.abs(2 * l - 1)) * s;
      const x = c * (1 - Math.abs((h / 60) % 2 - 1));
      const m = l - c / 2;
      let r = 0, g = 0, b = 0;
      if (h < 60) { r = c; g = x; }
      else if (h < 120) { r = x; g = c; }
      else if (h < 180) { g = c; b = x; }
      else if (h < 240) { g = x; b = c; }
      else if (h < 300) { r = x; b = c; }
      else { r = c; b = x; }
      return `rgba(${Math.round((r + m) * 255)}, ${Math.round((g + m) * 255)}, ${Math.round((b + m) * 255)}, ${a})`;
    }

    // Draw electrified lightning bolt between two points
    function drawLightning(x1: number, y1: number, x2: number, y2: number, color: string, glowColor: string, intensity: number) {
      const dx = x2 - x1;
      const dy = y2 - y1;
      const dist = Math.sqrt(dx * dx + dy * dy);

      // Number of segments based on distance and config
      const segments = Math.max(3, Math.floor(dist / config.lightningSegments));

      // Perpendicular vector for displacement
      const perpX = -dy / dist;
      const perpY = dx / dist;

      // Generate jagged path points
      const points: {x: number, y: number}[] = [{x: x1, y: y1}];

      for (let i = 1; i < segments; i++) {
        const t = i / segments;
        const baseX = x1 + dx * t;
        const baseY = y1 + dy * t;

        // Random displacement perpendicular to the line (using config jitter)
        const displacement = (Math.random() - 0.5) * dist * config.lightningJitter * intensity;

        points.push({
          x: baseX + perpX * displacement,
          y: baseY + perpY * displacement
        });
      }
      points.push({x: x2, y: y2});

      // Draw glow layer (thicker, more transparent)
      ctx.beginPath();
      ctx.moveTo(points[0].x, points[0].y);
      for (let i = 1; i < points.length; i++) {
        ctx.lineTo(points[i].x, points[i].y);
      }
      ctx.strokeStyle = glowColor;
      ctx.lineWidth = config.lightningGlow;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.stroke();

      // Draw main lightning bolt
      ctx.beginPath();
      ctx.moveTo(points[0].x, points[0].y);
      for (let i = 1; i < points.length; i++) {
        ctx.lineTo(points[i].x, points[i].y);
      }
      ctx.strokeStyle = color;
      ctx.lineWidth = 1.5;
      ctx.stroke();

      // Draw bright core
      ctx.beginPath();
      ctx.moveTo(points[0].x, points[0].y);
      for (let i = 1; i < points.length; i++) {
        ctx.lineTo(points[i].x, points[i].y);
      }
      ctx.strokeStyle = `rgba(255, 255, 255, ${intensity * 0.3})`;
      ctx.lineWidth = 0.5;
      ctx.stroke();
    }

    // Draw simple straight line
    function drawLine(x1: number, y1: number, x2: number, y2: number, color: string) {
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.strokeStyle = color;
      ctx.lineWidth = 1;
      ctx.stroke();
    }

    // Trigger a new pulse wave from mouse position
    function triggerPulse() {
      const maxRadius = Math.max(width, height) * 1.5;
      pulseWaves.push({
        x: mouse.x,
        y: mouse.y,
        radius: 0,
        startTime: performance.now(),
        maxRadius: maxRadius
      });
    }

    // Calculate pulse intensity at a given point
    function getPulseIntensity(x: number, y: number, time: number): number {
      let maxIntensity = 0;

      pulseWaves.forEach(pulse => {
        const dx = x - pulse.x;
        const dy = y - pulse.y;
        const distFromOrigin = Math.sqrt(dx * dx + dy * dy);

        // Distance from the pulse ring
        const distFromRing = Math.abs(distFromOrigin - pulse.radius);

        // Within the pulse width?
        if (distFromRing < config.pulseWidth) {
          // Intensity falls off with distance from ring center
          const ringIntensity = 1 - (distFromRing / config.pulseWidth);

          // Echo effect: intensity decreases as pulse expands (like fading heartbeat)
          const echoFalloff = 1 - (pulse.radius / pulse.maxRadius);

          // Combined intensity
          const intensity = ringIntensity * echoFalloff * config.pulseIntensity;
          maxIntensity = Math.max(maxIntensity, intensity);
        }
      });

      return maxIntensity;
    }

    // Draw edge with pulse effect
    function drawPulsedEdge(x1: number, y1: number, x2: number, y2: number, baseColor: string, baseOpacity: number, time: number) {
      // Get pulse intensity at midpoint of edge
      const midX = (x1 + x2) / 2;
      const midY = (y1 + y2) / 2;
      const pulseIntensity = getPulseIntensity(midX, midY, time);

      if (pulseIntensity > 0.01) {
        // Parse base color and blend with pulse color
        const pulseOpacity = baseOpacity + pulseIntensity * 0.6;

        // Draw pulse glow
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.strokeStyle = hexToRgba(config.pulseColor, pulseIntensity * 0.3);
        ctx.lineWidth = 3 + pulseIntensity * 4;
        ctx.lineCap = 'round';
        ctx.stroke();

        // Draw main line with pulse color blend
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.strokeStyle = hexToRgba(config.pulseColor, Math.min(pulseOpacity, 0.8));
        ctx.lineWidth = 1 + pulseIntensity * 2;
        ctx.stroke();
      } else {
        // Normal edge rendering
        drawLine(x1, y1, x2, y2, hexToRgba(baseColor, baseOpacity));
      }
    }

    // Snake game functions
    function showSnakeIntro() {
      const intro = document.getElementById('snake-intro');
      const introContent = document.getElementById('snake-intro-content');
      const countdown = document.getElementById('snake-countdown');

      if (!intro || !introContent || !countdown) return;

      // Show overlay
      intro.classList.remove('opacity-0', 'pointer-events-none');
      intro.classList.add('opacity-100', 'pointer-events-auto');

      // Show intro content, hide countdown
      introContent.classList.remove('hidden');
      countdown.classList.add('hidden');

      // Animate intro content in
      setTimeout(() => {
        introContent.classList.remove('scale-95', 'opacity-0');
        introContent.classList.add('scale-100', 'opacity-100');
      }, 50);
    }

    function hideSnakeIntro() {
      const intro = document.getElementById('snake-intro');
      const introContent = document.getElementById('snake-intro-content');

      if (!intro || !introContent) return;

      introContent.classList.add('scale-95', 'opacity-0');
      introContent.classList.remove('scale-100', 'opacity-100');

      setTimeout(() => {
        intro.classList.add('opacity-0', 'pointer-events-none');
        intro.classList.remove('opacity-100', 'pointer-events-auto');
      }, 200);
    }

    function runCountdown(callback: () => void) {
      const intro = document.getElementById('snake-intro');
      const introContent = document.getElementById('snake-intro-content');
      const countdown = document.getElementById('snake-countdown');
      const countdownNumber = document.getElementById('snake-countdown-number');

      if (!introContent || !countdown || !countdownNumber) return;

      // Hide intro, show countdown
      introContent.classList.add('hidden');
      countdown.classList.remove('hidden');

      const numbers = ['3', '2', '1', 'üêç'];
      let index = 0;

      function showNext() {
        if (index >= numbers.length) {
          // Hide overlay and start game
          if (intro) {
            intro.classList.add('opacity-0', 'pointer-events-none');
            intro.classList.remove('opacity-100', 'pointer-events-auto');
          }
          callback();
          return;
        }

        countdownNumber.textContent = numbers[index];
        countdownNumber.style.transform = 'scale(0.5)';
        countdownNumber.style.opacity = '0';

        // Animate in
        setTimeout(() => {
          countdownNumber.style.transition = 'all 0.3s ease-out';
          countdownNumber.style.transform = 'scale(1)';
          countdownNumber.style.opacity = '1';
        }, 50);

        // Animate out and show next
        setTimeout(() => {
          countdownNumber.style.transform = 'scale(1.5)';
          countdownNumber.style.opacity = '0';
          index++;
          setTimeout(showNext, 200);
        }, 700);
      }

      showNext();
    }

    function hidePageContent() {
      // Hide main content areas
      const mainContent = document.querySelector('main');
      const header = document.querySelector('header');
      const footer = document.querySelector('footer');
      const siteHeader = document.querySelector('.animate-fade-in');

      [mainContent, header, footer, siteHeader].forEach(el => {
        if (el) {
          (el as HTMLElement).style.transition = 'opacity 0.5s ease-out, transform 0.5s ease-out';
          (el as HTMLElement).style.opacity = '0';
          (el as HTMLElement).style.transform = 'translateY(-30px)';
          (el as HTMLElement).style.pointerEvents = 'none';
        }
      });

      // Hide floating buttons (snake + settings)
      const floatingBtns = document.getElementById('open-network-config')?.parentElement;
      if (floatingBtns) {
        (floatingBtns as HTMLElement).style.transition = 'opacity 0.3s ease-out';
        (floatingBtns as HTMLElement).style.opacity = '0';
        (floatingBtns as HTMLElement).style.pointerEvents = 'none';
      }
    }

    function showPageContent() {
      const mainContent = document.querySelector('main');
      const header = document.querySelector('header');
      const footer = document.querySelector('footer');
      const siteHeader = document.querySelector('.animate-fade-in');

      [mainContent, header, footer, siteHeader].forEach(el => {
        if (el) {
          (el as HTMLElement).style.opacity = '1';
          (el as HTMLElement).style.transform = 'translateY(0)';
          (el as HTMLElement).style.pointerEvents = '';
        }
      });

      // Show floating buttons again
      const floatingBtns = document.getElementById('open-network-config')?.parentElement;
      if (floatingBtns) {
        (floatingBtns as HTMLElement).style.opacity = '1';
        (floatingBtns as HTMLElement).style.pointerEvents = '';
      }
    }

    function launchSnakeGame() {
      showSnakeIntro();
    }

    function handleTouchStart(e: TouchEvent) {
      if (!snakeActive || snakeGameOver) return;
      touchStartX = e.touches[0].clientX;
      touchStartY = e.touches[0].clientY;
    }

    function handleTouchEnd(e: TouchEvent) {
      if (!snakeActive || snakeGameOver) return;
      touchEndX = e.changedTouches[0].clientX;
      touchEndY = e.changedTouches[0].clientY;
      handleSwipe();
    }

    function handleSwipe() {
      const deltaX = touchEndX - touchStartX;
      const deltaY = touchEndY - touchStartY;
      const absDeltaX = Math.abs(deltaX);
      const absDeltaY = Math.abs(deltaY);

      // Check if swipe is long enough
      if (absDeltaX < minSwipeDistance && absDeltaY < minSwipeDistance) {
        return;
      }

      // Determine swipe direction (horizontal or vertical)
      if (absDeltaX > absDeltaY) {
        // Horizontal swipe
        if (deltaX > 0 && snakeDirection.x !== -1) {
          // Swipe right
          snakeNextDirection = { x: 1, y: 0 };
        } else if (deltaX < 0 && snakeDirection.x !== 1) {
          // Swipe left
          snakeNextDirection = { x: -1, y: 0 };
        }
      } else {
        // Vertical swipe
        if (deltaY > 0 && snakeDirection.y !== -1) {
          // Swipe down
          snakeNextDirection = { x: 0, y: 1 };
        } else if (deltaY < 0 && snakeDirection.y !== 1) {
          // Swipe up
          snakeNextDirection = { x: 0, y: -1 };
        }
      }
    }

    function setSnakeDirection(x: number, y: number) {
      if (snakeActive && !snakeGameOver) {
        // Check if direction is allowed (no 180-degree turns)
        if ((x === 1 && snakeDirection.x !== -1) ||
            (x === -1 && snakeDirection.x !== 1) ||
            (y === 1 && snakeDirection.y !== -1) ||
            (y === -1 && snakeDirection.y !== 1)) {
          snakeNextDirection = { x, y };
        }
      }
    }

    function startSnake() {
      snakeActive = true;
      snakeGameOver = false;
      snakeScore = 0;
      snakeSpeed = 100; // Reset speed
      snake = [];

      // Hide page content
      hidePageContent();

      // Show HUD
      const hud = document.getElementById('snake-hud');
      const hudHigh = document.getElementById('snake-hud-high');
      if (hud) {
        hud.classList.remove('opacity-0', 'pointer-events-none');
        hud.classList.add('opacity-100', 'pointer-events-auto');
      }
      if (hudHigh) hudHigh.textContent = String(snakeHighScore);

      // Show mobile controls on touch devices
      const mobileControls = document.getElementById('snake-mobile-controls');
      if (mobileControls && ('ontouchstart' in window || navigator.maxTouchPoints > 0)) {
        mobileControls.classList.remove('opacity-0', 'pointer-events-none');
        mobileControls.classList.add('opacity-100', 'pointer-events-auto');
      }

      // Start snake in center of screen
      const startX = Math.floor(width / 2 / snakeSegmentSize) * snakeSegmentSize;
      const startY = Math.floor(height / 2 / snakeSegmentSize) * snakeSegmentSize;

      // Create initial snake with 3 segments
      for (let i = 0; i < 3; i++) {
        snake.push({ x: startX - i * snakeSegmentSize, y: startY });
      }

      snakeDirection = { x: 1, y: 0 };
      snakeNextDirection = { x: 1, y: 0 };
      lastSnakeMove = performance.now();

      updateSnakeScore();
    }

    function stopSnake() {
      snakeActive = false;
      snakeGameOver = false;
      snake = [];

      // Show page content again
      showPageContent();

      // Hide HUD
      const hud = document.getElementById('snake-hud');
      if (hud) {
        hud.classList.add('opacity-0', 'pointer-events-none');
        hud.classList.remove('opacity-100', 'pointer-events-auto');
      }

      // Hide mobile controls
      const mobileControls = document.getElementById('snake-mobile-controls');
      if (mobileControls) {
        mobileControls.classList.add('opacity-0', 'pointer-events-none');
        mobileControls.classList.remove('opacity-100', 'pointer-events-auto');
      }
    }

    function updateSnakeScore() {
      // Update HUD
      const hudScore = document.getElementById('snake-hud-score');
      if (hudScore) hudScore.textContent = String(snakeScore);
    }

    function gameOver() {
      snakeGameOver = true;
      gameOverTime = performance.now();

      // Update high score
      if (snakeScore > snakeHighScore) {
        snakeHighScore = snakeScore;
        try {
          localStorage.setItem('snakeHighScore', String(snakeHighScore));
        } catch (e) {}
        // Update HUD
        const hudHigh = document.getElementById('snake-hud-high');
        if (hudHigh) hudHigh.textContent = String(snakeHighScore);
      }
    }

    function respawnNode(index: number) {
      if (nodes[index]) {
        nodes[index].x = Math.random() * width;
        nodes[index].y = Math.random() * height;
      }
    }

    function updateSnake(currentTime: number) {
      if (!snakeActive || snakeGameOver) return;

      // Check if enough time has passed for next move
      if (currentTime - lastSnakeMove < snakeSpeed) return;
      lastSnakeMove = currentTime;

      // Apply queued direction
      snakeDirection = { ...snakeNextDirection };

      // Calculate new head position
      const head = snake[0];
      const newHead = {
        x: head.x + snakeDirection.x * snakeSegmentSize,
        y: head.y + snakeDirection.y * snakeSegmentSize
      };

      // Check wall collision (game over)
      if (newHead.x < 0 || newHead.x >= width || newHead.y < 0 || newHead.y >= height) {
        gameOver();
        return;
      }

      // Check self collision
      for (let i = 0; i < snake.length; i++) {
        if (newHead.x === snake[i].x && newHead.y === snake[i].y) {
          gameOver();
          return;
        }
      }

      // Add new head
      snake.unshift(newHead);

      // Check if eating a node
      let ate = false;
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        const dx = newHead.x + snakeSegmentSize / 2 - node.x;
        const dy = newHead.y + snakeSegmentSize / 2 - node.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < snakeSegmentSize) {
          // Eat the node!
          ate = true;
          snakeScore++;
          updateSnakeScore();
          respawnNode(i);

          // Speed up slightly
          snakeSpeed = Math.max(50, snakeSpeed - 1);

          // Trigger a pulse from the eaten position
          if (config.pulseEnabled) {
            pulseWaves.push({
              x: node.x,
              y: node.y,
              radius: 0,
              startTime: currentTime,
              maxRadius: 200
            });
          }
          break;
        }
      }

      // Remove tail if didn't eat
      if (!ate) {
        snake.pop();
      }
    }

    function drawSnake() {
      if (snake.length === 0) return;

      const currentTime = performance.now();

      // Game over flash effect
      if (snakeGameOver) {
        const elapsed = currentTime - gameOverTime;
        if (elapsed < 1000) {
          const flash = Math.sin(elapsed / 50) * 0.5 + 0.5;
          ctx.fillStyle = `rgba(255, 0, 0, ${flash * 0.3})`;
          ctx.fillRect(0, 0, width, height);
        } else {
          // Restart after animation
          stopSnake();
          return;
        }
      }

      // Draw snake body (from tail to head for proper layering)
      for (let i = snake.length - 1; i >= 0; i--) {
        const segment = snake[i];
        const isHead = i === 0;
        const progress = i / snake.length;

        // Size decreases from head to tail
        const size = isHead ? snakeSegmentSize : snakeSegmentSize * (0.6 + 0.4 * (1 - progress));
        const offset = (snakeSegmentSize - size) / 2;

        // Glow effect
        const glowSize = isHead ? 8 : 4;
        ctx.beginPath();
        ctx.roundRect(segment.x + offset - glowSize/2, segment.y + offset - glowSize/2, size + glowSize, size + glowSize, size / 3);
        ctx.fillStyle = isHead ? 'rgba(34, 197, 94, 0.4)' : 'rgba(34, 197, 94, 0.2)';
        ctx.fill();

        // Main segment
        ctx.beginPath();
        ctx.roundRect(segment.x + offset, segment.y + offset, size, size, size / 3);
        ctx.fillStyle = isHead ? '#22c55e' : `rgba(34, 197, 94, ${0.9 - progress * 0.4})`;
        ctx.fill();

        // Eye on head
        if (isHead) {
          const eyeSize = 3;
          const eyeOffset = snakeSegmentSize / 3;

          // Position eyes based on direction
          let eyeX1 = segment.x + snakeSegmentSize / 2;
          let eyeY1 = segment.y + snakeSegmentSize / 2;
          let eyeX2 = eyeX1;
          let eyeY2 = eyeY1;

          if (snakeDirection.x === 1) { // Right
            eyeX1 += eyeOffset / 2; eyeY1 -= eyeOffset / 2;
            eyeX2 += eyeOffset / 2; eyeY2 += eyeOffset / 2;
          } else if (snakeDirection.x === -1) { // Left
            eyeX1 -= eyeOffset / 2; eyeY1 -= eyeOffset / 2;
            eyeX2 -= eyeOffset / 2; eyeY2 += eyeOffset / 2;
          } else if (snakeDirection.y === -1) { // Up
            eyeX1 -= eyeOffset / 2; eyeY1 -= eyeOffset / 2;
            eyeX2 += eyeOffset / 2; eyeY2 -= eyeOffset / 2;
          } else { // Down
            eyeX1 -= eyeOffset / 2; eyeY1 += eyeOffset / 2;
            eyeX2 += eyeOffset / 2; eyeY2 += eyeOffset / 2;
          }

          ctx.beginPath();
          ctx.arc(eyeX1, eyeY1, eyeSize, 0, Math.PI * 2);
          ctx.arc(eyeX2, eyeY2, eyeSize, 0, Math.PI * 2);
          ctx.fillStyle = '#fff';
          ctx.fill();

          ctx.beginPath();
          ctx.arc(eyeX1, eyeY1, eyeSize / 2, 0, Math.PI * 2);
          ctx.arc(eyeX2, eyeY2, eyeSize / 2, 0, Math.PI * 2);
          ctx.fillStyle = '#000';
          ctx.fill();
        }
      }
    }

    function init() {
      resize();
      nodes = [];
      for (let i = 0; i < config.nodeCount; i++) {
        nodes.push({
          x: Math.random() * width,
          y: Math.random() * height,
          vx: (Math.random() - 0.5) * config.nodeSpeed,
          vy: (Math.random() - 0.5) * config.nodeSpeed,
          radius: Math.random() * config.nodeSize + 1,
          hue: Math.random() * 360,
        });
      }
    }

    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
      updateHeaderPosition();
    }

    function updateHeaderPosition() {
      headings = [];
      // Find the site header elements (title h1 and description p)
      const siteHeaderLink = document.getElementById('site-header-link');
      if (siteHeaderLink) {
        // Get the h1 title
        const h1 = siteHeaderLink.querySelector('h1');
        if (h1) {
          const rect = h1.getBoundingClientRect();
          if (rect.width > 0) {
            headings.push({
              x: rect.left + rect.width / 2,
              y: rect.top + rect.height / 2,
              width: rect.width,
              height: rect.height
            });
          }
        }
        // Get the sibling p (description)
        const description = siteHeaderLink.parentElement?.querySelector('p');
        if (description) {
          const rect = description.getBoundingClientRect();
          if (rect.width > 0) {
            headings.push({
              x: rect.left + rect.width / 2,
              y: rect.top + rect.height / 2,
              width: rect.width,
              height: rect.height
            });
          }
        }
      }
    }

    function animate() {
      const currentTime = performance.now();
      ctx.clearRect(0, 0, width, height);

      // Update pulse waves
      if (config.pulseEnabled) {
        // Auto-trigger pulses
        if (config.pulseAuto && currentTime - lastPulseTime > config.pulseInterval * 1000) {
          triggerPulse();
          lastPulseTime = currentTime;
        }

        // Expand pulse radii and remove completed ones
        pulseWaves = pulseWaves.filter(pulse => {
          const elapsed = currentTime - pulse.startTime;
          pulse.radius = elapsed * (config.pulseSpeed / 1000) * 60; // 60fps normalized
          return pulse.radius < pulse.maxRadius;
        });
      }

      nodes.forEach((node, i) => {
        // Apply shake effect from pulses
        let shakeX = 0;
        let shakeY = 0;
        if (config.pulseEnabled && config.pulseShake) {
          const pulseIntensity = getPulseIntensity(node.x, node.y, currentTime);
          if (pulseIntensity > 0.1) {
            const shakeStrength = pulseIntensity * 8;
            shakeX = (Math.random() - 0.5) * shakeStrength;
            shakeY = (Math.random() - 0.5) * shakeStrength;
          }
        }

        node.x += node.vx;
        node.y += node.vy;

        if (node.x < 0 || node.x > width) node.vx *= -1;
        if (node.y < 0 || node.y > height) node.vy *= -1;

        node.x = Math.max(0, Math.min(width, node.x));
        node.y = Math.max(0, Math.min(height, node.y));

        // Update hue for rainbow mode
        if (config.rainbowMode && node.hue !== undefined) {
          node.hue = (node.hue + 0.5) % 360;
        }

        // Render position with shake
        const renderX = node.x + shakeX;
        const renderY = node.y + shakeY;

        // Get pulse intensity for node glow
        const nodePulseIntensity = config.pulseEnabled ? getPulseIntensity(renderX, renderY, currentTime) : 0;

        // Draw node with pulse glow
        if (nodePulseIntensity > 0.1) {
          // Pulse glow around node
          ctx.beginPath();
          ctx.arc(renderX, renderY, node.radius + nodePulseIntensity * 6, 0, Math.PI * 2);
          ctx.fillStyle = hexToRgba(config.pulseColor, nodePulseIntensity * 0.4);
          ctx.fill();
        }

        // Draw node
        ctx.beginPath();
        ctx.arc(renderX, renderY, node.radius, 0, Math.PI * 2);
        ctx.fillStyle = config.rainbowMode
          ? hslToRgba(node.hue!, 0.7, 0.5, config.nodeOpacity)
          : hexToRgba(config.nodeColor, config.nodeOpacity);
        ctx.fill();

        // Connect to nearby nodes
        if (config.nodeEdgesEnabled) {
          for (let j = i + 1; j < nodes.length; j++) {
            const other = nodes[j];

            // Other node's shake
            let otherShakeX = 0;
            let otherShakeY = 0;
            if (config.pulseEnabled && config.pulseShake) {
              const otherPulseIntensity = getPulseIntensity(other.x, other.y, currentTime);
              if (otherPulseIntensity > 0.1) {
                const shakeStrength = otherPulseIntensity * 8;
                otherShakeX = (Math.random() - 0.5) * shakeStrength;
                otherShakeY = (Math.random() - 0.5) * shakeStrength;
              }
            }

            const otherRenderX = other.x + otherShakeX;
            const otherRenderY = other.y + otherShakeY;

            const ndx = node.x - other.x;
            const ndy = node.y - other.y;
            const ndist = Math.sqrt(ndx * ndx + ndy * ndy);

            if (ndist < config.connectionDistance) {
              const opacity = config.lineOpacity * (1 - ndist / config.connectionDistance);

              if (config.pulseEnabled) {
                const baseColor = config.rainbowMode ? config.lineColor : config.lineColor;
                drawPulsedEdge(renderX, renderY, otherRenderX, otherRenderY, baseColor, opacity, currentTime);
              } else {
                const lineColor = config.rainbowMode
                  ? hslToRgba((node.hue! + other.hue!) / 2, 0.7, 0.5, opacity)
                  : hexToRgba(config.lineColor, opacity);
                drawLine(renderX, renderY, otherRenderX, otherRenderY, lineColor);
              }
            }
          }
        }

        // Connect to mouse
        if (config.mouseEdgesEnabled) {
          const dx = node.x - mouse.x;
          const dy = node.y - mouse.y;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (dist < config.mouseRadius) {
            const intensity = 1 - dist / config.mouseRadius;

            if (config.mouseLightning) {
              const mainColor = config.rainbowMode
                ? hslToRgba(node.hue!, 0.8, 0.6, intensity * 0.8)
                : hexToRgba(config.mouseLineColor, intensity * 0.7);
              const glowColor = config.rainbowMode
                ? hslToRgba(node.hue!, 0.6, 0.5, intensity * 0.15)
                : hexToRgba(config.mouseLineColor, intensity * 0.1);
              drawLightning(node.x, node.y, mouse.x, mouse.y, mainColor, glowColor, intensity);
            } else {
              const lineColor = config.rainbowMode
                ? hslToRgba(node.hue!, 0.7, 0.5, intensity * 0.5)
                : hexToRgba(config.mouseLineColor, intensity * 0.4);
              drawLine(node.x, node.y, mouse.x, mouse.y, lineColor);
            }
          }
        }

        // Connect to headings (h1, h2, h3)
        if (config.headerEdgesEnabled && headings.length > 0) {
          headings.forEach(heading => {
            // Calculate distance to nearest point on heading rectangle
            const closestX = Math.max(heading.x - heading.width / 2, Math.min(renderX, heading.x + heading.width / 2));
            const closestY = Math.max(heading.y - heading.height / 2, Math.min(renderY, heading.y + heading.height / 2));
            const hdx = renderX - closestX;
            const hdy = renderY - closestY;
            const hdist = Math.sqrt(hdx * hdx + hdy * hdy);

            if (hdist < config.headerRadius && hdist > 0) {
              const intensity = 1 - hdist / config.headerRadius;

              if (config.headerLightning) {
                const mainColor = config.rainbowMode
                  ? hslToRgba(node.hue!, 0.8, 0.6, intensity * 0.6)
                  : hexToRgba(config.headerLineColor, intensity * 0.5);
                const glowColor = config.rainbowMode
                  ? hslToRgba(node.hue!, 0.6, 0.5, intensity * 0.12)
                  : hexToRgba(config.headerLineColor, intensity * 0.08);
                drawLightning(renderX, renderY, closestX, closestY, mainColor, glowColor, intensity);
              } else {
                const lineColor = config.rainbowMode
                  ? hslToRgba(node.hue!, 0.7, 0.5, intensity * 0.25)
                  : hexToRgba(config.headerLineColor, intensity * 0.25);
                drawLine(renderX, renderY, closestX, closestY, lineColor);
              }
            }
          });
        }
      });

      // Update and draw snake
      if (snakeActive) {
        updateSnake(currentTime);
        drawSnake();
      }

      animationId = requestAnimationFrame(animate);
    }

    function updateConfigUI() {
      // Range inputs with value display
      const rangeInputs = [
        'nodeCount', 'nodeSize', 'nodeSpeed', 'nodeOpacity',
        'connectionDistance', 'lineOpacity',
        'mouseRadius',
        'headerRadius',
        'lightningJitter', 'lightningSegments', 'lightningGlow',
        'pulseSpeed', 'pulseWidth', 'pulseIntensity', 'pulseInterval'
      ];
      rangeInputs.forEach(id => {
        const el = document.getElementById(id) as HTMLInputElement;
        const valueEl = document.getElementById(`${id}-value`);
        if (el) {
          el.value = String(config[id as keyof typeof config]);
          if (valueEl) valueEl.textContent = String(config[id as keyof typeof config]);
        }
      });

      // Color inputs
      ['nodeColor', 'lineColor', 'mouseLineColor', 'headerLineColor', 'pulseColor'].forEach(id => {
        const el = document.getElementById(id) as HTMLInputElement;
        if (el) el.value = String(config[id as keyof typeof config]);
      });

      // Checkbox inputs
      const checkboxInputs = [
        'nodeEdgesEnabled', 'mouseEdgesEnabled', 'headerEdgesEnabled',
        'mouseLightning', 'headerLightning',
        'pulseEnabled', 'pulseAuto', 'pulseShake'
      ];
      checkboxInputs.forEach(id => {
        const el = document.getElementById(id) as HTMLInputElement;
        if (el) el.checked = Boolean(config[id as keyof typeof config]);
      });
    }

    function setupConfigListeners() {
      // Range inputs
      const rangeInputs = [
        'nodeCount', 'nodeSize', 'nodeSpeed', 'nodeOpacity',
        'connectionDistance', 'lineOpacity',
        'mouseRadius',
        'headerRadius',
        'lightningJitter', 'lightningSegments', 'lightningGlow',
        'pulseSpeed', 'pulseWidth', 'pulseIntensity', 'pulseInterval'
      ];
      rangeInputs.forEach(id => {
        const el = document.getElementById(id) as HTMLInputElement;
        const valueEl = document.getElementById(`${id}-value`);
        if (el) {
          el.addEventListener('input', () => {
            const val = parseFloat(el.value);
            (config as any)[id] = val;
            if (valueEl) valueEl.textContent = String(val);
            if (id === 'nodeCount' || id === 'nodeSize') init();
            saveConfig();
          });
        }
      });

      // Color inputs
      ['nodeColor', 'lineColor', 'mouseLineColor', 'headerLineColor', 'pulseColor'].forEach(id => {
        const el = document.getElementById(id) as HTMLInputElement;
        if (el) {
          el.addEventListener('input', () => {
            (config as any)[id] = el.value;
            config.rainbowMode = false;
            saveConfig();
          });
        }
      });

      // Checkbox inputs
      const checkboxInputs = [
        'nodeEdgesEnabled', 'mouseEdgesEnabled', 'headerEdgesEnabled',
        'mouseLightning', 'headerLightning',
        'pulseEnabled', 'pulseAuto', 'pulseShake'
      ];
      checkboxInputs.forEach(id => {
        const el = document.getElementById(id) as HTMLInputElement;
        if (el) {
          el.addEventListener('change', () => {
            (config as any)[id] = el.checked;
            saveConfig();
          });
        }
      });

      // Pulse trigger button
      const pulseTriggerBtn = document.getElementById('pulseTrigger');
      if (pulseTriggerBtn) {
        pulseTriggerBtn.addEventListener('click', () => {
          triggerPulse();
        });
      }

      // Floating snake button
      const snakeFloatBtn = document.getElementById('play-snake-float');
      if (snakeFloatBtn) {
        snakeFloatBtn.addEventListener('click', () => {
          if (!snakeActive) {
            launchSnakeGame();
          }
        });
      }

      // Ready button in intro overlay
      const snakeReadyBtn = document.getElementById('snake-ready-btn');
      if (snakeReadyBtn) {
        snakeReadyBtn.addEventListener('click', () => {
          runCountdown(() => {
            startSnake();
          });
        });
      }

      // HUD quit button
      const snakeHudQuit = document.getElementById('snake-hud-quit');
      if (snakeHudQuit) {
        snakeHudQuit.addEventListener('click', () => {
          stopSnake();
        });
      }

      // Mobile control buttons
      const btnUp = document.getElementById('snake-btn-up');
      const btnDown = document.getElementById('snake-btn-down');
      const btnLeft = document.getElementById('snake-btn-left');
      const btnRight = document.getElementById('snake-btn-right');

      if (btnUp) {
        btnUp.addEventListener('click', (e) => {
          e.preventDefault();
          setSnakeDirection(0, -1);
        });
        btnUp.addEventListener('touchstart', (e) => {
          e.preventDefault();
          setSnakeDirection(0, -1);
        });
      }
      if (btnDown) {
        btnDown.addEventListener('click', (e) => {
          e.preventDefault();
          setSnakeDirection(0, 1);
        });
        btnDown.addEventListener('touchstart', (e) => {
          e.preventDefault();
          setSnakeDirection(0, 1);
        });
      }
      if (btnLeft) {
        btnLeft.addEventListener('click', (e) => {
          e.preventDefault();
          setSnakeDirection(-1, 0);
        });
        btnLeft.addEventListener('touchstart', (e) => {
          e.preventDefault();
          setSnakeDirection(-1, 0);
        });
      }
      if (btnRight) {
        btnRight.addEventListener('click', (e) => {
          e.preventDefault();
          setSnakeDirection(1, 0);
        });
        btnRight.addEventListener('touchstart', (e) => {
          e.preventDefault();
          setSnakeDirection(1, 0);
        });
      }

      // Touch/swipe event listeners for gesture controls
      canvas.addEventListener('touchstart', handleTouchStart, { passive: true });
      canvas.addEventListener('touchend', handleTouchEnd, { passive: true });

      // Also trigger pulse on canvas click
      canvas.addEventListener('click', (e) => {
        if (config.pulseEnabled) {
          mouse.x = e.clientX;
          mouse.y = e.clientY;
          triggerPulse();
        }
      });

      // Presets
      document.querySelectorAll('[data-preset]').forEach(btn => {
        btn.addEventListener('click', () => {
          const presetName = (btn as HTMLElement).dataset.preset!;
          const preset = presets[presetName];
          if (preset) {
            Object.assign(config, { ...defaultConfig, ...preset });
            updateConfigUI();
            init();
            saveConfig();
          }
        });
      });
    }

    // Theme toggle functionality
    const themeLightBtn = document.getElementById('theme-light');
    const themeDarkBtn = document.getElementById('theme-dark');
    const themeSystemBtn = document.getElementById('theme-system');

    function getThemePreference(): 'light' | 'dark' | 'system' {
      try {
        return (localStorage.getItem('theme') as 'light' | 'dark' | 'system') || 'system';
      } catch (e) {
        return 'system';
      }
    }

    function applyTheme(theme: 'light' | 'dark' | 'system', animate = true) {
      const wasDark = document.documentElement.classList.contains('dark');
      const isDark = theme === 'dark' ||
        (theme === 'system' && window.matchMedia('(prefers-color-scheme: dark)').matches);

      // Only animate if theme actually changes
      if (animate && wasDark !== isDark) {
        const overlay = document.getElementById('theme-transition');
        if (overlay) {
          // Get button position for radial origin
          const btn = isDark ? themeDarkBtn : themeLightBtn;
          if (btn) {
            const rect = btn.getBoundingClientRect();
            overlay.style.setProperty('--x', `${rect.left + rect.width / 2}px`);
            overlay.style.setProperty('--y', `${rect.top + rect.height / 2}px`);
          }

          overlay.classList.remove('to-dark', 'to-light', 'active');
          overlay.classList.add(isDark ? 'to-dark' : 'to-light');

          // Force reflow
          void overlay.offsetWidth;

          overlay.classList.add('active');

          // Remove classes after animation
          setTimeout(() => {
            overlay.classList.remove('active', 'to-dark', 'to-light');
          }, 400);
        }
      }

      document.documentElement.classList.toggle('dark', isDark);

      try {
        localStorage.setItem('theme', theme);
      } catch (e) {}

      updateThemeButtons(theme);
    }

    function updateThemeButtons(theme: 'light' | 'dark' | 'system') {
      const activeClass = 'bg-primary text-white';
      const inactiveClass = 'hover:bg-gray-300 dark:hover:bg-slate-600';

      [themeLightBtn, themeDarkBtn, themeSystemBtn].forEach(btn => {
        btn?.classList.remove('bg-primary', 'text-white', 'hover:bg-gray-300', 'dark:hover:bg-slate-600');
      });

      if (theme === 'light') {
        themeLightBtn?.classList.add('bg-primary', 'text-white');
        themeDarkBtn?.classList.add('hover:bg-gray-300', 'dark:hover:bg-slate-600');
        themeSystemBtn?.classList.add('hover:bg-gray-300', 'dark:hover:bg-slate-600');
      } else if (theme === 'dark') {
        themeDarkBtn?.classList.add('bg-primary', 'text-white');
        themeLightBtn?.classList.add('hover:bg-gray-300', 'dark:hover:bg-slate-600');
        themeSystemBtn?.classList.add('hover:bg-gray-300', 'dark:hover:bg-slate-600');
      } else {
        themeSystemBtn?.classList.add('bg-primary', 'text-white');
        themeLightBtn?.classList.add('hover:bg-gray-300', 'dark:hover:bg-slate-600');
        themeDarkBtn?.classList.add('hover:bg-gray-300', 'dark:hover:bg-slate-600');
      }
    }

    // Initialize theme buttons state
    updateThemeButtons(getThemePreference());

    themeLightBtn?.addEventListener('click', () => applyTheme('light'));
    themeDarkBtn?.addEventListener('click', () => applyTheme('dark'));
    themeSystemBtn?.addEventListener('click', () => applyTheme('system'));

    // Listen for system theme changes when in system mode
    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
      if (getThemePreference() === 'system') {
        applyTheme('system');
      }
    });

    function openConfigPanel() {
      configPanel.classList.remove('opacity-0', 'pointer-events-none', 'translate-x-4');
      configPanel.classList.add('opacity-100', 'pointer-events-auto', 'translate-x-0');
    }

    function closeConfigPanel() {
      configPanel.classList.add('opacity-0', 'pointer-events-none', 'translate-x-4');
      configPanel.classList.remove('opacity-100', 'pointer-events-auto', 'translate-x-0');
    }

    function toggleConfigPanel() {
      if (configPanel.classList.contains('opacity-0')) {
        openConfigPanel();
      } else {
        closeConfigPanel();
      }
    }

    // Open config panel from buttons
    openBtnFloat?.addEventListener('click', (e) => {
      e.stopPropagation();
      toggleConfigPanel();
    });
    openBtnHeader?.addEventListener('click', (e) => {
      e.stopPropagation();
      toggleConfigPanel();
    });

    // Keyboard shortcut: Ctrl+Shift+G
    document.addEventListener('keydown', (e) => {
      if (e.ctrlKey && e.shiftKey && e.key === 'G') {
        e.preventDefault();
        toggleConfigPanel();
      }

      // Snake controls
      if (snakeActive && !snakeGameOver) {
        const key = e.key.toLowerCase();

        // Prevent 180-degree turns
        if ((key === 'arrowup' || key === 'w') && snakeDirection.y !== 1) {
          e.preventDefault();
          snakeNextDirection = { x: 0, y: -1 };
        } else if ((key === 'arrowdown' || key === 's') && snakeDirection.y !== -1) {
          e.preventDefault();
          snakeNextDirection = { x: 0, y: 1 };
        } else if ((key === 'arrowleft' || key === 'a') && snakeDirection.x !== 1) {
          e.preventDefault();
          snakeNextDirection = { x: -1, y: 0 };
        } else if ((key === 'arrowright' || key === 'd') && snakeDirection.x !== -1) {
          e.preventDefault();
          snakeNextDirection = { x: 1, y: 0 };
        }
      }

      // Escape to quit snake game or close intro
      if (e.key === 'Escape') {
        if (snakeActive) {
          stopSnake();
        } else {
          // Close intro overlay if open
          const intro = document.getElementById('snake-intro');
          if (intro && !intro.classList.contains('opacity-0')) {
            hideSnakeIntro();
          }
        }
      }
    });

    closeBtn?.addEventListener('click', closeConfigPanel);

    // Close on click outside
    document.addEventListener('click', (e) => {
      const target = e.target as HTMLElement;
      if (!configPanel.contains(target) &&
          target !== openBtnFloat &&
          target !== openBtnHeader &&
          !openBtnFloat?.contains(target) &&
          !openBtnHeader?.contains(target) &&
          !configPanel.classList.contains('opacity-0')) {
        closeConfigPanel();
      }
    });

    function handleMouseMove(e: MouseEvent) {
      mouse.x = e.clientX;
      mouse.y = e.clientY;
    }

    function handleTouchMove(e: TouchEvent) {
      if (e.touches.length > 0) {
        mouse.x = e.touches[0].clientX;
        mouse.y = e.touches[0].clientY;
      }
    }

    function cleanup() {
      cancelAnimationFrame(animationId);
      window.removeEventListener('resize', handleResize);
      window.removeEventListener('mousemove', handleMouseMove);
      window.removeEventListener('touchmove', handleTouchMove);
      window.removeEventListener('scroll', updateHeaderPosition);
    }

    function handleResize() {
      resize();
      init();
    }

    // Initialize
    updateConfigUI();
    setupConfigListeners();
    init();
    animate();

    // Event listeners
    window.addEventListener('resize', handleResize);
    window.addEventListener('mousemove', handleMouseMove);
    window.addEventListener('touchmove', handleTouchMove);
    window.addEventListener('scroll', updateHeaderPosition, { passive: true });

    // Cleanup on page navigation
    document.addEventListener('astro:before-swap', cleanup, { once: true });
  }

  // Run on initial load
  initNetwork();

  // Re-run after View Transitions
  document.addEventListener('astro:after-swap', initNetwork);
</script>
